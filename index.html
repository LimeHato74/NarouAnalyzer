<!DOCTYPE html>
<html lang="ja" data-theme="winter">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>Narou Analyzer Pro - なろう系Web小説の文体・内容評価スコアリングツール</title>
    <meta name="description" content="小説家になろう等のWeb小説執筆者向け無料分析ツール。異世界、ファンタジー、恋愛などジャンルに合わせて文体リズム、五感描写、感情曲線をAIが自動採点。">
    
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@3.9.4/dist/full.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=BIZ+UDGothic:wght@400;700&family=Zen+Maru+Gothic:wght@500;700&display=swap');
        
        body { font-family: 'Zen Maru Gothic', sans-serif; transition: background-color 0.3s, color 0.3s; }
        .font-mono-jp { font-family: 'BIZ UDGothic', monospace; }
        
        [v-cloak] { display: none; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        
        .glass-panel {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        [data-theme="night"] .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .animate-fade-in-up { animation: fadeInUp 0.5s ease-out forwards; }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        
        .animate-bounce-in { animation: bounceIn 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55); }
        @keyframes bounceIn { 0% { transform: scale(0.3); opacity: 0; } 50% { transform: scale(1.05); opacity: 1; } 70% { transform: scale(0.9); } 100% { transform: scale(1); } }
    </style>
</head>
<body class="min-h-screen bg-base-200 flex flex-col">

<div id="app" v-cloak class="flex-grow">
    <header class="navbar glass-panel sticky top-0 z-50 shadow-sm px-4">
        <div class="flex-1">
            <h1 class="text-xl md:text-2xl font-black text-primary flex items-center gap-2 tracking-tighter cursor-pointer" onclick="window.scrollTo(0,0)">
                <i class="ph-fill ph-pen-nib-straight"></i> 
                <span>Narou<span class="hidden md:inline"> Analyzer Pro</span></span>
            </h1>
        </div>
        <div class="flex-none gap-2">
            <button class="btn btn-ghost btn-xs md:btn-sm" onclick="my_modal_2.showModal()">
                <i class="ph-fill ph-shield-check text-success"></i> 安全性について
            </button>
            <label class="swap swap-rotate btn btn-ghost btn-circle btn-sm">
                <input type="checkbox" v-model="isDarkMode" />
                <i class="ph-fill ph-sun swap-on text-yellow-500 text-xl"></i>
                <i class="ph-fill ph-moon swap-off text-indigo-500 text-xl"></i>
            </label>
        </div>
    </header>

    <main class="p-4 md:p-8 max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-6 pb-32">
        <section class="lg:col-span-4 space-y-4">
            <div class="card bg-base-100 shadow-lg">
                <div class="card-body p-4">
                    <label class="label pt-0"><span class="label-text font-bold text-gray-500">執筆ジャンルを選択</span></label>
                    <select v-model="selectedGenre" class="select select-bordered w-full select-sm md:select-md font-bold text-base">
                        <template v-for="(subGenres, mainGenre) in genreDefinitions" :key="mainGenre">
                            <optgroup :label="mainGenre">
                                <option v-for="sub in subGenres" :value="sub.id">{{ sub.name }}</option>
                            </optgroup>
                        </template>
                    </select>
                    
                    <div class="mt-3 bg-base-200 p-3 rounded-lg text-xs space-y-2">
                        <div class="flex items-start gap-2">
                            <i class="ph-fill ph-info text-primary mt-0.5"></i> 
                            <span class="font-bold">{{ currentGenreSettings.desc }}</span>
                        </div>
                        <div class="divider my-1"></div>
                        <div class="grid grid-cols-2 gap-2 text-gray-500">
                            <div><span class="badge badge-xs badge-neutral mr-1">重視</span>{{ currentScoringProfile.focus }}</div>
                            <div><span class="badge badge-xs badge-ghost mr-1">目標</span>{{ currentScoringProfile.targetLen }}文字/文</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card bg-base-100 shadow-xl border-t-4 border-primary">
                <div class="card-body p-4 md:p-6">
                    <div class="flex justify-between items-end mb-2">
                        <h2 class="text-sm font-bold text-gray-500 uppercase tracking-wider">本文入力</h2>
                        <span class="text-xs badge" :class="inputText.length > 0 ? 'badge-primary' : 'badge-ghost'">{{ inputText.length.toLocaleString() }} chars</span>
                    </div>
                    <textarea v-model="inputText" class="textarea textarea-bordered w-full h-[40vh] lg:h-[60vh] font-mono-jp text-base leading-8 resize-none focus:outline-none focus:border-primary transition-all" :class="{'bg-gray-50 text-gray-800': !isDarkMode, 'bg-gray-800 text-gray-100': isDarkMode}" placeholder="ここに小説の本文を貼り付けてください。&#10;※データはサーバーに送信されず、ブラウザ内で安全に解析されます。"></textarea>
                </div>
            </div>
        </section>

        <section class="lg:col-span-8 space-y-6" id="results-area">
            <div v-if="!stats" class="flex flex-col h-full min-h-[400px]">
                <div class="flex-1 flex flex-col items-center justify-center text-base-content/30 border-2 border-dashed border-base-300 rounded-box p-8 mb-6">
                    <i class="ph ph-brain text-6xl mb-4 animate-pulse"></i>
                    <p class="text-lg font-bold">AI文体診断 & 感情分析</p>
                    <p class="text-sm mt-2">ジャンルごとに最適化された基準で採点します</p>
                </div>
            </div>

            <div v-if="stats" class="space-y-6 animate-fade-in-up">
                
                <div class="card bg-base-100 shadow-xl overflow-hidden relative">
                    <div class="absolute top-0 left-0 w-2 h-full" :class="rankColorClass"></div>
                    <div class="card-body p-5 md:p-8">
                        <div class="flex flex-col md:flex-row gap-6 items-center">
                            <div class="text-center md:text-left min-w-[140px]">
                                <div class="text-xs text-gray-400 font-bold mb-1">総合スコア</div>
                                <div class="text-8xl font-black leading-none bg-clip-text text-transparent bg-gradient-to-br" :class="rankGradient">{{ stats.totalScore.toFixed(0) }}</div>
                                <div class="badge badge-lg mt-2 font-bold w-full shadow-sm" :class="rankBadgeColor">Rank {{ stats.rank }}</div>
                            </div>
                            <div class="flex-1 w-full bg-base-200/50 p-4 rounded-xl border border-base-300 relative">
                                <i class="ph-fill ph-quotes text-4xl absolute -top-3 -left-2 text-base-content/10"></i>
                                <h3 class="font-bold text-sm mb-2 flex items-center gap-2"><i class="ph-fill ph-robot text-primary"></i> AI講評 ({{ getGenreName(selectedGenre) }}基準)</h3>
                                <p class="text-sm md:text-base leading-relaxed opacity-90 whitespace-pre-line">{{ stats.comment }}</p>
                            </div>
                        </div>

                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-6 pt-6 border-t border-base-200">
                            <div class="text-center" v-for="(metric, idx) in stats.radarData" :key="idx">
                                <div class="text-xs text-gray-500 mb-1 flex justify-center items-center gap-1">
                                    {{ metric.label }}
                                    <span class="tooltip" :data-tip="'重み: ' + metric.weight + '%'">
                                        <i class="ph-bold ph-info text-xs text-gray-300"></i>
                                    </span>
                                </div>
                                <div class="radial-progress text-sm font-bold" :class="getScoreColor(metric.score)" :style="{'--value': metric.score, '--size': '3rem'}">{{ metric.score }}</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="card bg-base-100 shadow-lg">
                        <div class="card-body p-4">
                            <h3 class="font-bold text-sm text-gray-500 flex items-center gap-2"><i class="ph-fill ph-heartbeat text-pink-500"></i> ストーリー感情曲線</h3>
                            <div class="relative w-full h-[200px]"><canvas id="sentimentChart"></canvas></div>
                        </div>
                    </div>
                    <div class="card bg-base-100 shadow-lg">
                        <div class="card-body p-4">
                            <h3 class="font-bold text-sm text-gray-500 flex items-center gap-2"><i class="ph-fill ph-radar"></i> 評価バランス (ジャンル別重み適用)</h3>
                            <div class="relative w-full h-[200px] flex justify-center"><canvas id="radarChart"></canvas></div>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="card bg-base-100 shadow-lg">
                        <div class="card-body p-0">
                            <div class="p-4 border-b border-base-200 bg-base-50 rounded-t-xl"><h3 class="card-title text-base"><i class="ph-fill ph-check-circle text-success"></i> 改善アドバイス</h3></div>
                            <div class="overflow-x-auto">
                                <table class="table table-sm">
                                    <tbody>
                                        <tr v-for="item in adviceList" :key="item.label">
                                            <td class="font-bold whitespace-nowrap pl-4">{{ item.label }}</td>
                                            <td class="text-right pr-4">
                                                <div class="flex flex-col items-end">
                                                    <span class="font-mono font-bold" :class="item.statusColor">{{ item.value }}</span>
                                                    <span class="text-[10px] text-gray-400">{{ item.target }}</span>
                                                </div>
                                            </td>
                                            <td class="text-xs text-gray-600 pr-4">{{ item.msg }}</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <div class="card bg-base-100 shadow-lg">
                        <div class="card-body p-4">
                            <h3 class="font-bold text-sm text-gray-500 flex items-center gap-2"><i class="ph-fill ph-eye text-teal-500"></i> 五感指数 & キーワード</h3>
                            <div class="space-y-3 mt-2">
                                <div v-for="(val, key) in stats.contentMetrics.senses" :key="key">
                                    <div class="flex justify-between text-xs mb-1 uppercase font-bold text-gray-400">
                                        <span>{{ key }}</span><span>Lv.{{ Math.min(5, Math.ceil(val/2)) }}</span>
                                    </div>
                                    <progress class="progress w-full h-2" 
                                        :class="{'progress-error': key==='sight', 'progress-info': key==='sound', 'progress-warning': key==='touch'}" 
                                        :value="Math.min(100, val * 10)" max="100"></progress>
                                </div>
                                
                                <div class="bg-base-200 p-3 rounded-lg mt-4">
                                    <div class="text-xs font-bold text-gray-500 mb-2">ジャンル検出語句 (Top 10)</div>
                                    <div class="flex flex-wrap gap-1">
                                        <span v-for="word in stats.contentMetrics.foundKeywords" :key="word" class="badge badge-sm badge-outline bg-base-100 text-xs">{{ word }}</span>
                                        <span v-if="stats.contentMetrics.foundKeywords.length === 0" class="text-xs text-gray-400">検出なし</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </section>
    </main>

    <div class="fixed bottom-4 left-0 right-0 px-4 z-40 flex flex-col gap-2 items-center pointer-events-none">
        <div v-if="toastMessage" class="alert shadow-lg w-auto min-w-[300px] animate-bounce-in pointer-events-auto" :class="toastType">
            <i class="ph-fill text-xl" :class="toastIcon"></i><span>{{ toastMessage }}</span>
        </div>
        <button @click="analyzeText" :disabled="isProcessing || inputText.length < 10" class="btn btn-primary btn-lg w-full max-w-md shadow-2xl border-t border-white/20 pointer-events-auto transition-all transform active:scale-95 hover:-translate-y-1">
            <span v-if="isProcessing" class="loading loading-spinner"></span>
            <span v-else class="flex items-center gap-2"><i class="ph-bold ph-lightning"></i><span>{{ getGenreName(selectedGenre) }}基準で診断</span></span>
        </button>
    </div>
</div>

<dialog id="my_modal_2" class="modal">
  <div class="modal-box">
    <h3 class="font-bold text-lg text-success flex items-center gap-2"><i class="ph-fill ph-lock-key"></i> データ保護について</h3>
    <p class="py-4">このツールはブラウザ内（JavaScript）のみで処理を行います。入力されたテキストがサーバーに送信されたり保存されたりすることは一切ありません。</p>
    <div class="modal-action"><form method="dialog"><button class="btn">閉じる</button></form></div>
  </div>
  <form method="dialog" class="modal-backdrop"><button>close</button></form>
</dialog>

<script>
    // --- Configuration & Data ---
    const DICTIONARIES = {
        positive: ['好き', '愛', '嬉しい', '楽しい', '幸せ', '光', '笑顔', '希望', '成功', '美しい', '最高', '安心', '温かい', '喜び', '勝利', '素敵', 'ありがとう', '仲間', '絆', '回復', '救い', '優雅', '可憐', '爽快'],
        negative: ['嫌い', '憎', '悲しい', '辛い', '苦しい', '闇', '涙', '絶望', '失敗', '醜い', '最悪', '不安', '冷たい', '怒り', '敗北', '死', '殺', '痛い', '怖い', '恐怖', '孤独', '裏切り', '叫び', '血', '傷', '魔', '呪'],
        sight: ['見る', '見え', '視線', '色', '赤', '青', '黒', '白', '輝', '暗', '光', '姿', '景色', '瞳', '鮮やか', 'ぼんやり', '映る', '金', '銀', '紫', '眺', '目撃'],
        sound: ['聞', '音', '声', '響', '静寂', '叫', '囁', '歌', '騒', '耳', '轟', 'メロディ', '悲鳴', 'ざわ', '沈黙', 'ノイズ', '爆音'],
        touch: ['痛', '熱', '冷', '触', '肌', '震', '重', '軽', '硬', '柔', '風', '撫', '殴', '体温', '痺', '湿', '乾', '衝撃'],
        genres: {
            isekai: ['魔法', 'スキル', 'レベル', '剣', 'ギルド', '魔王', '勇者', '転生', '召喚', 'ステータス', '王女', '令嬢', '婚約破棄', '王子', '貴族', 'ダンジョン', '冒険者', 'チート', '悪役', '聖女'],
            real_love: ['学校', '教室', '先輩', '後輩', '部活', '放課後', 'デート', '告白', '携帯', 'スマホ', '仕事', '会社', '結婚', '離婚', '浮気', '彼氏', '彼女', '恋人', 'カフェ', '電車'],
            high_fantasy: ['剣', '魔法', 'ドラゴン', 'エルフ', 'ドワーフ', '王国', '帝国', '精霊', '神', '呪い', '城', '騎士', '森', '旅', '伝説', '戦記', '軍', '皇帝'],
            mystery: ['殺人', '死体', '警察', '刑事', '探偵', '証拠', 'トリック', '犯人', '密室', '動機', 'アリバイ', '事件', '推理', '謎', '血痕', '指紋', '嘘'],
            horror: ['血', '死', '呪', '霊', '幽霊', '闇', '悲鳴', '恐怖', '殺', '逃', '狂', '影', '化け物', '廃墟', '夜', '背後', '気配', '不気味'],
            scifi: ['宇宙', 'ロボット', 'AI', '船', '星', '未来', '科学', '実験', '博士', '機械', 'システム', 'データ', '仮想', 'VR', 'レーザー', '次元', 'ワープ'],
            battle: ['殴', '蹴', '撃', '殺', '血', '弾', '剣', '銃', '爆発', '敵', '味方', '勝利', '敗北', '死闘', '技', '能力', '覚醒']
        }
    };
    
    const GENRE_PARAMS = {
        'isekai':       { name: '異世界(なろう系)', type: 'light_novel', keywords: 'isekai', desc: 'テンポとカタルシス重視' },
        'real_love':    { name: '現代恋愛', type: 'romance', keywords: 'real_love', desc: '感情の揺れ動きと会話' },
        'high_fantasy': { name: 'ハイファンタジー', type: 'epic', keywords: 'high_fantasy', desc: '世界観描写と重厚さ' },
        'low_fantasy':  { name: 'ローファンタジー', type: 'light_novel', keywords: 'isekai', desc: '現代的価値観×ファンタジー' },
        'pure_lit':     { name: '純文学', type: 'literature', keywords: null, desc: '文章の美しさと五感描写' },
        'human':        { name: 'ヒューマンドラマ', type: 'standard', keywords: 'real_love', desc: '人間関係の機微' },
        'mystery':      { name: 'ミステリー', type: 'logic', keywords: 'mystery', desc: '論理構成と事実関係' },
        'horror':       { name: 'ホラー', type: 'atmosphere', keywords: 'horror', desc: '恐怖演出と五感への刺激' },
        'action':       { name: 'アクション', type: 'action', keywords: 'battle', desc: '戦闘のスピード感' },
        'comedy':       { name: 'コメディー', type: 'comedy', keywords: null, desc: '会話のテンポと勢い' },
        'scifi':        { name: 'SF', type: 'logic', keywords: 'scifi', desc: '設定の緻密さ' },
        'essay':        { name: 'エッセイ', type: 'standard', keywords: null, desc: '構成と言葉選び' }
    };

    // 評価プロファイル（厳格化：ペナルティ係数を強化）
    const SCORING_PROFILES = {
        light_novel: { 
            targetLen: 35, lenPenalty: 4.0, minDialog: 25, 
            focus: 'テンポ・会話',
            weights: { form: 15, read: 35, imm: 35, cont: 15 } 
        },
        romance: { 
            targetLen: 40, lenPenalty: 3.0, minDialog: 30, 
            focus: '会話・感情',
            weights: { form: 15, read: 25, imm: 35, cont: 25 } 
        },
        epic: { 
            targetLen: 60, lenPenalty: 2.0, minDialog: 10, 
            focus: '描写・世界観',
            weights: { form: 25, read: 25, imm: 10, cont: 40 } 
        },
        literature: { 
            targetLen: 65, lenPenalty: 1.5, minDialog: 5, 
            focus: '表現力・五感',
            weights: { form: 30, read: 10, imm: 10, cont: 50 } 
        },
        logic: { 
            targetLen: 55, lenPenalty: 2.5, minDialog: 20, 
            focus: '構成・キーワード',
            weights: { form: 30, read: 20, imm: 10, cont: 40 } 
        },
        atmosphere: { 
            targetLen: 45, lenPenalty: 2.5, minDialog: 15, 
            focus: '雰囲気・五感',
            weights: { form: 15, read: 20, imm: 10, cont: 55 } 
        },
        action: { 
            targetLen: 30, lenPenalty: 5.0, minDialog: 10, 
            focus: '疾走感',
            weights: { form: 15, read: 45, imm: 10, cont: 30 } 
        },
        comedy: { 
            targetLen: 30, lenPenalty: 4.0, minDialog: 45, 
            focus: '会話の勢い',
            weights: { form: 10, read: 30, imm: 55, cont: 5 } 
        },
        standard: { 
            targetLen: 45, lenPenalty: 3.0, minDialog: 20, 
            focus: 'バランス',
            weights: { form: 25, read: 25, imm: 25, cont: 25 } 
        }
    };

    const { createApp, ref, computed, watch, nextTick } = Vue;

    createApp({
        setup() {
            const inputText = ref('');
            const selectedGenre = ref('isekai');
            const isProcessing = ref(false);
            const stats = ref(null);
            const adviceList = ref([]);
            const isDarkMode = ref(false);
            const toastMessage = ref('');
            const toastType = ref('alert-info');
            let radarChart = null;
            let sentimentChart = null;

            const genreDefinitions = {
                'トレンド': [ { id: 'isekai', name: '異世界(なろう系)' }, { id: 'real_love', name: '現代恋愛' }, { id: 'comedy', name: 'ラブコメ・コメディー' } ],
                'ファンタジー': [ { id: 'high_fantasy', name: 'ハイファンタジー' }, { id: 'low_fantasy', name: 'ローファンタジー' }, { id: 'action', name: 'アクション・バトル' } ],
                '文芸・小説': [ { id: 'pure_lit', name: '純文学' }, { id: 'human', name: 'ヒューマンドラマ' }, { id: 'mystery', name: 'ミステリー・推理' }, { id: 'horror', name: 'ホラー' }, { id: 'scifi', name: 'SF' } ],
                'その他': [ { id: 'essay', name: 'エッセイ・その他' } ]
            };

            const currentGenreSettings = computed(() => GENRE_PARAMS[selectedGenre.value] || GENRE_PARAMS['human']);
            const currentScoringProfile = computed(() => SCORING_PROFILES[currentGenreSettings.value.type] || SCORING_PROFILES['standard']);

            watch(isDarkMode, (newVal) => {
                document.documentElement.setAttribute('data-theme', newVal ? 'night' : 'winter');
                updateChartTheme();
            });

            const getGenreName = (id) => (GENRE_PARAMS[id] || GENRE_PARAMS['human']).name;
            const showToast = (msg, type = 'alert-info') => {
                toastMessage.value = msg;
                toastType.value = type;
                setTimeout(() => { toastMessage.value = ''; }, 3000);
            };
            const toastIcon = computed(() => {
                if (toastType.value.includes('success')) return 'ph-check-circle';
                if (toastType.value.includes('error')) return 'ph-warning-circle';
                return 'ph-info';
            });
            const getScoreColor = (score) => {
                if (score >= 80) return 'text-success';
                if (score >= 60) return 'text-info';
                if (score >= 40) return 'text-warning';
                return 'text-error';
            };

            const analyzeContent = (tokens, genreKey) => {
                let posScore = 0, negScore = 0;
                let senses = { sight: 0, sound: 0, touch: 0 };
                let genreMatchCount = 0;
                const foundKeywords = new Set();
                const sentimentTimeline = [];
                let currentChunkScore = 0;
                
                const chunkSize = Math.max(10, Math.ceil(tokens.length / 20));
                const targetGenreKey = GENRE_PARAMS[genreKey].keywords;
                const genreWords = targetGenreKey ? DICTIONARIES.genres[targetGenreKey] : [];

                tokens.forEach((token, index) => {
                    let val = 0;
                    if (DICTIONARIES.positive.some(w => token.includes(w))) { posScore++; val = 1; }
                    if (DICTIONARIES.negative.some(w => token.includes(w))) { negScore++; val = -1; }
                    
                    if (DICTIONARIES.sight.some(w => token.includes(w))) senses.sight++;
                    if (DICTIONARIES.sound.some(w => token.includes(w))) senses.sound++;
                    if (DICTIONARIES.touch.some(w => token.includes(w))) senses.touch++;
                    
                    if (genreWords && genreWords.some(w => token.includes(w))) { 
                        genreMatchCount++; 
                        foundKeywords.add(token); 
                    }

                    currentChunkScore += val;
                    if ((index + 1) % chunkSize === 0 || index === tokens.length - 1) {
                        sentimentTimeline.push(currentChunkScore);
                        currentChunkScore = 0;
                    }
                });

                const smoothedTimeline = sentimentTimeline.map((val, i, arr) => {
                    const prev = arr[i-1] || val;
                    const next = arr[i+1] || val;
                    return (prev + val + next) / 3;
                });

                // 五感スコア算出（厳しく調整）
                const totalSenses = senses.sight + senses.sound + senses.touch;
                const sensoryRatio = (totalSenses / Math.max(1, tokens.length)) * 1000;
                const isLit = GENRE_PARAMS[genreKey].type === 'literature' || GENRE_PARAMS[genreKey].type === 'atmosphere';
                // 以前より基準を厳しく：短い文章で稼ぎにくくする
                const sensoryScore = Math.min(10, Math.ceil(sensoryRatio / (isLit ? 2.5 : 1.5)));

                return {
                    sentimentTimeline: smoothedTimeline,
                    senses,
                    sensoryScore, 
                    genreMatchCount,
                    foundKeywords: Array.from(foundKeywords).slice(0, 10)
                };
            };

            // 新機能：文末重複チェック
            const checkRepetition = (sentences) => {
                let penalty = 0;
                let streak = 0;
                let lastEnd = '';
                
                // 簡易的な文末取得（「〜た。」「〜る。」など）
                const endings = sentences.map(s => {
                    const match = s.match(/[ぁ-んァ-ヶ]+[。！？]/);
                    return match ? match[0].slice(-2) : null; 
                });

                for (let i = 1; i < endings.length; i++) {
                    if (endings[i] && endings[i] === endings[i-1]) {
                        streak++;
                        if (streak >= 2) penalty += 5; // 3回連続で減点開始
                    } else {
                        streak = 0;
                    }
                }
                return Math.min(40, penalty); // 最大40点減点
            };

            // 新機能：Web小説マナーチェック
            const checkFormat = (text) => {
                let penalty = 0;
                const msgs = [];
                
                // 感嘆符の後のスペース漏れ (!?のあとに空白がない)
                if (/[！？](?![ \u3000\n」])/.test(text)) {
                    penalty += 10;
                    msgs.push('感嘆符(!?)の後に空白を入れるのがWeb小説の定石です。');
                }
                // 三点リーダーの誤用
                if (/\.\.\.|・・・|…(?![…])|(?<![…])…/.test(text)) {
                    // 「…」が奇数個、または「...」「・・・」を使用
                    if (!/……/.test(text)) {
                        penalty += 5;
                        msgs.push('三点リーダーは「……」のように2つ重ねるのが一般的です。');
                    }
                }
                // 句読点の誤用（閉じ括弧の前の句点）
                if (/。[」』]/.test(text)) {
                    penalty += 5;
                    msgs.push('会話文の閉じ括弧の前に句点（。）は不要です。');
                }

                return { penalty: Math.min(30, penalty), msgs };
            };

            const analyzeText = async () => {
                if (inputText.value.length < 10) return;
                isProcessing.value = true;
                await new Promise(r => setTimeout(r, 600));

                try {
                    const text = inputText.value;
                    const genreKey = selectedGenre.value;
                    const genreDef = GENRE_PARAMS[genreKey];
                    const profile = SCORING_PROFILES[genreDef.type] || SCORING_PROFILES['standard'];

                    let tokens = [];
                    if (window.Intl && Intl.Segmenter) {
                        const segmenter = new Intl.Segmenter('ja', { granularity: 'word' });
                        for (const seg of segmenter.segment(text)) { if (seg.isWordLike) tokens.push(seg.segment); }
                    } else { tokens = text.split(/[\s\u3000、。！？\(\)「」]+/); }
                    
                    const lines = text.split('\n');
                    const sentences = text.split(/[。！？\n]/).filter(s => s.trim().length > 0);
                    
                    const avgLen = sentences.reduce((a,b)=>a+b.length,0) / (sentences.length || 1);
                    const dialogueRatio = ((text.match(/「[^」]+」/g) || []).join('').length / (text.length || 1)) * 100;
                    const kanjiRatio = ((text.match(/[\u4E00-\u9FFF]/g) || []).length / (text.replace(/\s/g,'').length || 1)) * 100;
                    const cMetrics = analyzeContent(tokens, genreKey);

                    // --- Dynamic Scoring System (Stricter) ---
                    
                    // 1. Form Score (文体・形式) - 減点方式強化
                    let formScore = 100;
                    const maxKanji = profile.type === 'literature' ? 50 : 35;
                    if (kanjiRatio > maxKanji) formScore -= (kanjiRatio - maxKanji) * 3; // 係数強化
                    
                    // 新規：文末重複ペナルティ
                    const repPenalty = checkRepetition(sentences);
                    formScore -= repPenalty;

                    // 新規：フォーマットペナルティ
                    const formatCheck = checkFormat(text);
                    formScore -= formatCheck.penalty;

                    formScore = Math.max(0, Math.min(100, formScore));

                    // 2. Readability Score (可読性) - 許容範囲狭小化
                    let readScore = 100;
                    const lenDiff = Math.abs(avgLen - profile.targetLen);
                    // 許容範囲を±5から±3へ、ペナルティ係数を強化
                    if (lenDiff > 3) {
                        readScore -= (lenDiff - 3) * profile.lenPenalty;
                    }
                    readScore = Math.max(0, Math.min(100, readScore));

                    // 3. Immersion Score (構成)
                    let immScore = 100;
                    if (dialogueRatio < profile.minDialog) {
                        immScore -= (profile.minDialog - dialogueRatio) * 2.0; // 減点強化
                    } 
                    // 会話文多すぎペナルティ（台本書き対策）
                    if (genreDef.type !== 'comedy' && dialogueRatio > 80) {
                        immScore -= (dialogueRatio - 80) * 3;
                    }
                    immScore = Math.max(0, Math.min(100, immScore));

                    // 4. Content Score (内容) - 基礎点大幅ダウン
                    // 以前は60点スタートでしたが、40点スタートに変更。
                    // 何も書かないと赤点になるように調整。
                    let contScore = 40; 
                    
                    // 感情ボーナス（上限厳格化）
                    const range = Math.max(...cMetrics.sentimentTimeline) - Math.min(...cMetrics.sentimentTimeline);
                    contScore += Math.min(15, range * 3); 
                    
                    // 五感ボーナス
                    if (profile.focus.includes('描写') || profile.focus.includes('五感')) {
                        contScore += cMetrics.sensoryScore * 3; // Max 30
                        if(cMetrics.sensoryScore < 3) contScore -= 10;
                    } else {
                        contScore += cMetrics.sensoryScore * 1.5;
                    }
                    
                    // キーワード適合（Max 15点に制限）
                    if (genreDef.keywords) {
                        contScore += Math.min(15, cMetrics.genreMatchCount * 2);
                    }
                    contScore = Math.max(0, Math.min(100, contScore));


                    // --- Weighted Final Calculation ---
                    const weights = profile.weights;
                    const totalScore = (
                        (formScore * weights.form) + 
                        (readScore * weights.read) + 
                        (immScore * weights.imm) + 
                        (contScore * weights.cont)
                    ) / 100;

                    // Rank Thresholds (Strict)
                    // Sランクを92以上に引き上げ
                    let rank = totalScore >= 92 ? 'S' : totalScore >= 78 ? 'A' : totalScore >= 60 ? 'B' : totalScore >= 40 ? 'C' : 'D';
                    
                    // Comment Generation
                    let comment = "";
                    if (totalScore >= 92) {
                        comment = `極めて高い完成度です！\n${getGenreName(genreKey)}として文体・構成ともにプロレベルの品質に達しています。`;
                    } else if (totalScore >= 78) {
                        comment = `安定した筆力で、読み応えがあります。\nより${profile.focus}を意識すると、さらに上のランクを目指せます。`;
                    } else if (totalScore >= 60) {
                        comment = `基礎的な文章力は十分です。\n細かい作法や、${profile.focus}のバランスを見直すとより良くなります。`;
                    } else {
                        comment = `まずはジャンルの基本（${profile.focus}）を押さえましょう。\n形式や文法などの基礎点検から始めるのがおすすめです。`;
                    }

                    stats.value = {
                        rank,
                        totalScore,
                        comment,
                        radarData: [
                            { label: '文体形式', score: Math.round(formScore), weight: weights.form },
                            { label: '可読性', score: Math.round(readScore), weight: weights.read },
                            { label: '構成/会話', score: Math.round(immScore), weight: weights.imm },
                            { label: '内容/描写', score: Math.round(contScore), weight: weights.cont },
                        ],
                        contentMetrics: cMetrics
                    };

                    // Advice Generation
                    const list = [];
                    
                    // Format Advice (Priority)
                    if (formatCheck.msgs.length > 0) {
                         list.push({ 
                            label: '作法・形式', 
                            value: '要確認', 
                            target: 'Web標準', 
                            statusColor: 'text-error',
                            msg: formatCheck.msgs[0] // 最初の警告を表示
                        });
                    }

                    // Repetition Advice
                    if (repPenalty > 0) {
                        list.push({ 
                            label: '文末の重複', 
                            value: '単調', 
                            target: 'リズム感', 
                            statusColor: 'text-warning',
                            msg: '同じ語尾（〜た、〜る等）が続いています。体言止めなどを活用しましょう。'
                        });
                    }

                    const lenStatus = avgLen > profile.targetLen + 5 ? '長め' : avgLen < profile.targetLen - 5 ? '短め' : '適正';
                    list.push({ 
                        label: '平均文長', 
                        value: Math.round(avgLen) + '文字', 
                        target: `目安 ${profile.targetLen}`, 
                        statusColor: lenStatus === '適正' ? 'text-success' : 'text-warning',
                        msg: lenStatus === '長め' ? '一文を短く切るとテンポが出ます。' : lenStatus === '短め' ? '描写を足して深みを出せます。' : '読みやすい長さです。'
                    });

                    const talkStatus = dialogueRatio < profile.minDialog ? '少なめ' : '適正';
                    list.push({ 
                        label: '会話比率', 
                        value: Math.round(dialogueRatio) + '%', 
                        target: `目安 ${profile.minDialog}%`, 
                        statusColor: talkStatus === '適正' ? 'text-success' : 'text-warning',
                        msg: talkStatus === '少なめ' ? `キャラの掛け合い（${profile.focus}）を増やしましょう。` : 'テンポ良い構成です。'
                    });
                    
                    list.push({
                        label: '漢字含有率',
                        value: Math.round(kanjiRatio) + '%',
                        target: `目安 ${maxKanji}%`,
                        statusColor: kanjiRatio > maxKanji ? 'text-error' : 'text-success',
                        msg: kanjiRatio > maxKanji ? '少し硬い印象です。ひらがなを増やしましょう。' : '読みやすいバランスです。'
                    });

                    adviceList.value = list;

                    nextTick(() => {
                        renderCharts(stats.value);
                        document.getElementById('results-area').scrollIntoView({ behavior: 'smooth' });
                    });

                    showToast('解析完了！', 'alert-success');

                } catch (e) {
                    console.error(e);
                    showToast('エラーが発生しました。', 'alert-error');
                } finally {
                    isProcessing.value = false;
                }
            };

            const renderCharts = (data) => {
                const ctxRadar = document.getElementById('radarChart');
                const ctxSentiment = document.getElementById('sentimentChart');
                
                if (radarChart) radarChart.destroy();
                if (sentimentChart) sentimentChart.destroy();

                const textColor = isDarkMode.value ? '#cbd5e1' : '#475569';
                const gridColor = isDarkMode.value ? '#334155' : '#e2e8f0';

                radarChart = new Chart(ctxRadar, {
                    type: 'radar',
                    data: {
                        labels: data.radarData.map(d => d.label),
                        datasets: [{
                            label: 'スコア',
                            data: data.radarData.map(d => d.score),
                            backgroundColor: 'rgba(56, 189, 248, 0.2)',
                            borderColor: '#38bdf8',
                            pointBackgroundColor: '#38bdf8',
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            r: {
                                angleLines: { color: gridColor },
                                grid: { color: gridColor },
                                pointLabels: { color: textColor, font: { family: 'Zen Maru Gothic', size: 12 } },
                                min: 0, max: 100,
                                ticks: { display: false }
                            }
                        },
                        plugins: { legend: { display: false } }
                    }
                });

                sentimentChart = new Chart(ctxSentiment, {
                    type: 'line',
                    data: {
                        labels: data.contentMetrics.sentimentTimeline.map((_, i) => i),
                        datasets: [{
                            label: '感情値',
                            data: data.contentMetrics.sentimentTimeline,
                            borderColor: '#f472b6',
                            backgroundColor: 'rgba(244, 114, 182, 0.1)',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { display: false },
                            y: { display: false, grid: { display: false } }
                        },
                        plugins: { legend: { display: false }, tooltip: { enabled: false } },
                        elements: { point: { radius: 0 } }
                    }
                });
            };

            const updateChartTheme = () => {
                if (stats.value) renderCharts(stats.value);
            };

            const rankColorClass = computed(() => {
                if (!stats.value) return 'bg-gray-200';
                const r = stats.value.rank;
                return r==='S'?'bg-yellow-400': r==='A'?'bg-pink-400': r==='B'?'bg-blue-400': 'bg-gray-400';
            });
            const rankBadgeColor = computed(() => {
                if (!stats.value) return 'badge-ghost';
                const r = stats.value.rank;
                return r==='S'?'badge-warning text-yellow-900': r==='A'?'badge-secondary text-pink-900': r==='B'?'badge-info text-blue-900': 'badge-ghost';
            });
            const rankGradient = computed(() => {
                if (!stats.value) return '';
                const r = stats.value.rank;
                return r==='S'?'from-yellow-400 to-orange-500': r==='A'?'from-pink-400 to-rose-500': r==='B'?'from-cyan-400 to-blue-500': 'from-gray-400 to-slate-500';
            });

            return {
                inputText, selectedGenre, isProcessing, stats, adviceList,
                isDarkMode, toastMessage, toastType, toastIcon,
                genreDefinitions, currentGenreSettings, currentScoringProfile,
                analyzeText, getGenreName, getScoreColor,
                rankColorClass, rankBadgeColor, rankGradient
            };
        }
    }).mount('#app');
</script>
</body>
</html>
