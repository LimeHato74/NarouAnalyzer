<!DOCTYPE html>
<html lang="ja" data-theme="winter">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>Narou Analyzer Ultra3.2 - Created by ペンギンの搾り汁</title>
    <meta name="description" content="Web小説執筆者向け高精度分析ツール。恋愛、ファンタジー、SFなどジャンル別に評価">
    
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@3.9.4/dist/full.css" rel="stylesheet" type="text/css" />
    <script>
        // Tailwind CDN警告を非表示
        (function() {
            const originalWarn = console.warn;
            console.warn = function(...args) {
                if (args[0] && args[0].includes && args[0].includes('cdn.tailwindcss.com')) {
                    return;
                }
                originalWarn.apply(console, args);
            };
        })();
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=BIZ+UDGothic:wght@400;700&family=Zen+Maru+Gothic:wght@500;700&display=swap');
        
        body { font-family: 'Zen Maru Gothic', sans-serif; transition: background-color 0.3s, color 0.3s; }
        .font-mono-jp { font-family: 'BIZ UDGothic', monospace; line-height: 1.8; }
        
        [v-cloak] { display: none; }
        
        .glass-panel {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }
        [data-theme="night"] .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .animate-fade-in-up { animation: fadeInUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .animate-bounce-in { animation: bounceIn 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55); }
        @keyframes bounceIn { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        
        .pulse-ring { animation: pulseRing 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulseRing { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .fixed-button-bar {
            animation: slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }
        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
    </style>
    <meta name="google-site-verification" content="Qctxr2MQwkSNSHwyrfwkSR9HDis7BM0FjcSFREWI-YA" />
</head>
<body class="min-h-screen bg-base-200 flex flex-col">

<div id="app" v-cloak class="flex-grow">
    <header class="navbar glass-panel sticky top-0 z-50 px-4 transition-colors duration-300">
        <div class="flex-1 flex-col items-start">
            <h1 class="text-xl md:text-2xl font-black text-primary flex items-center gap-2 tracking-tighter cursor-pointer" onclick="window.scrollTo(0,0)">
                <i class="ph-fill ph-pen-nib-straight"></i> 
                <span>Narou Analyzer <span class="text-secondary">Ultra3.2</span></span>
            </h1>
            <div class="text-[10px] font-bold text-base-content/50 ml-8 -mt-1">Created by ペンギンの搾り汁</div>
        </div>
        <div class="flex-none gap-2 flex items-center">
            <!-- Xアカウントリンク -->
            <div class="dropdown dropdown-end">
                <label tabindex="0" class="btn btn-ghost btn-circle btn-sm">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                    </svg>
                </label>
                <ul tabindex="0" class="dropdown-content z-[100] menu p-2 shadow-lg bg-base-100 rounded-box w-64 mt-3 border border-base-300">
                    <li class="menu-title">
                        <span class="flex items-center gap-2">
                            <i class="ph-fill ph-user-circle text-primary"></i>
                            作者のXアカウント
                        </span>
                    </li>
                    <li>
                        <a href="https://x.com/petipeti_juice" target="_blank" rel="noopener noreferrer" class="flex items-center gap-3">
                            <i class="ph-fill ph-star text-yellow-500"></i>
                            <div class="flex-1">
                                <div class="font-bold">メインアカウント</div>
                                <div class="text-xs opacity-70">@petipeti_juice</div>
                            </div>
                            <i class="ph-bold ph-arrow-square-out text-base-content/50"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://x.com/Lime_Lemon_Hato" target="_blank" rel="noopener noreferrer" class="flex items-center gap-3">
                            <i class="ph-fill ph-bird text-sky-500"></i>
                            <div class="flex-1">
                                <div class="font-bold">サブアカウント</div>
                                <div class="text-xs opacity-70">@Lime_Lemon_Hato</div>
                            </div>
                            <i class="ph-bold ph-arrow-square-out text-base-content/50"></i>
                        </a>
                    </li>
                </ul>
            </div>
            
            <label class="swap swap-rotate btn btn-ghost btn-circle btn-sm">
                <input type="checkbox" v-model="isDarkMode" />
                <i class="ph-fill ph-sun swap-on text-yellow-500 text-xl"></i>
                <i class="ph-fill ph-moon swap-off text-indigo-500 text-xl"></i>
            </label>
        </div>
    </header>

    <main class="p-4 md:p-8 max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-6 pb-24 md:pb-28">
        <section class="lg:col-span-4 space-y-4">
            <div class="card bg-base-100 shadow-lg">
                <div class="card-body p-5">
                    <label class="label pt-0"><span class="label-text font-bold text-base-content/70">解析ジャンルを選択</span></label>
                    
                    <select v-model="selectedGenre" @change="onGenreChange" class="select select-bordered w-full font-bold text-base bg-base-200/50 focus:outline-none focus:border-secondary">
                        <optgroup v-for="(group, groupName) in groupedGenres" :label="groupName" :key="groupName">
                            <option v-for="g in group" :value="g.id" :key="g.id">
                                {{ g.name }}
                            </option>
                        </optgroup>
                    </select>
                    
                    <div class="mt-4 text-xs space-y-3">
                        <div class="flex gap-3 items-start p-3 rounded bg-primary/10 text-primary-content">
                            <i class="ph-fill ph-info text-xl mt-0.5 text-primary"></i>
                            <div>
                                <div class="font-bold text-primary">{{ currentScoringProfile.name }}</div>
                                <div class="opacity-80 leading-relaxed mt-1 text-base-content">{{ currentScoringProfile.desc }}</div>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2 text-base-content/60">
                            <div><i class="ph-bold ph-text-aa"></i> 目標文長: {{ currentScoringProfile.targetLen }}文字</div>
                            <div><i class="ph-bold ph-chats"></i> 目標会話: {{ currentScoringProfile.minDialog }}%</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card bg-base-100 shadow-xl border-t-4 border-secondary">
                <div class="card-body p-4 md:p-6">
                    <div class="flex justify-between items-end mb-2">
                        <h2 class="text-sm font-bold text-base-content/70 uppercase tracking-wider">本文入力</h2>
                        <span class="text-xs badge" :class="inputText.length > 2000 ? 'badge-success' : 'badge-ghost'">{{ inputText.length.toLocaleString() }} chars</span>
                    </div>
                    <textarea v-model="inputText" class="textarea textarea-bordered w-full h-[40vh] lg:h-[55vh] font-mono-jp text-base leading-relaxed resize-none focus:outline-none focus:border-secondary transition-all" placeholder="ここに小説の本文を貼り付けてください。&#10;&#10;Ultra3.2では、文末パターン、視点の一貫性、描写密度、接続詞の適切性、語彙の豊かさなど、数十項目の詳細な分析を行います。"></textarea>
                </div>
            </div>
        </section>

        <section class="lg:col-span-8 space-y-6" id="results-area">
            <div v-if="!stats" class="flex flex-col h-full min-h-[400px]">
                <div class="flex-1 flex flex-col items-center justify-center text-base-content/30 border-2 border-dashed border-base-300 rounded-3xl p-8 mb-6">
                    <i class="ph-duotone ph-books text-7xl mb-4 animate-pulse text-secondary"></i>
                    <p class="text-xl font-bold">高精度ジャンル別解析 Ultra3.2</p>
                    <p class="text-sm mt-2 opacity-70">恋愛・ファンタジー・文芸・SFなど全20カテゴリに対応</p>
                    <div class="mt-4 grid grid-cols-2 gap-2 text-xs opacity-60">
                        <div>✓ 文末パターン精密分析</div>
                        <div>✓ 視点一貫性チェック</div>
                        <div>✓ 多次元描写密度測定</div>
                        <div>✓ 冗長表現検出</div>
                        <div>✓ 語彙の豊かさ評価</div>
                        <div>✓ 接続詞適切性判定</div>
                    </div>
                    <div class="mt-8 text-xs font-mono opacity-50 bg-base-200 px-4 py-2 rounded-full">Designed by ペンギンの搾り汁</div>
                </div>
            </div>

            <div v-else class="space-y-6 animate-fade-in-up">
                
                <div class="card bg-base-100 shadow-xl overflow-visible relative">
                    <div class="absolute top-0 left-0 w-3 h-full" :class="rankColorClass"></div>
                    <div class="absolute -right-10 -top-10 opacity-5 rotate-12" style="overflow: hidden;">
                        <i class="ph-fill ph-medal text-9xl"></i>
                    </div>
                    
                    <div class="card-body p-6 md:p-8 overflow-visible">
                        <div class="flex flex-col md:flex-row gap-8 items-center">
                            <div class="text-center min-w-[160px] relative">
                                <div class="text-xs text-base-content/60 font-bold mb-1 uppercase tracking-widest flex items-center justify-center gap-2">
                                    Genre Rank
                                    <span v-if="isAIMode && !isAIProcessing && aiComment" class="badge badge-sm badge-secondary animate-pulse">AI採点</span>
                                </div>
                                <div class="text-9xl font-black leading-none bg-clip-text text-transparent bg-gradient-to-br filter drop-shadow-sm" :class="rankGradient" style="font-family: 'Zen Maru Gothic';">{{ stats.rank }}</div>
                                <div class="text-3xl font-bold mt-[-10px] text-base-content/50">{{ stats.totalScore.toFixed(1) }}<span class="text-sm">/100</span></div>
                            </div>
                            
                            <div class="flex-1 w-full space-y-4 overflow-visible">
                                <div class="bg-base-200/60 p-5 rounded-2xl border border-base-300 relative">
                                    <h3 class="font-bold text-sm mb-2 flex items-center gap-2 text-secondary">
                                        <i class="ph-fill ph-robot"></i> {{ currentScoringProfile.name }}としての評価
                                    </h3>
                                    <p class="text-sm md:text-base leading-7 whitespace-pre-line text-base-content">{{ stats.comment }}</p>
                                </div>
                                
                                <!-- AI感想表示 -->
                                <div v-if="isAIMode" class="bg-gradient-to-br from-purple-50 to-pink-50 dark:from-purple-900/20 dark:to-pink-900/20 p-5 rounded-2xl border-2 border-purple-200 dark:border-purple-700">
                                    <h3 class="font-bold text-sm mb-3 flex items-center gap-2 text-purple-700 dark:text-purple-300">
                                        <i class="ph-fill ph-heart"></i> AI読後感想
                                    </h3>
                                    <div v-if="isAIProcessing" class="flex items-center gap-3 text-purple-600 dark:text-purple-400">
                                        <span class="loading loading-spinner loading-sm"></span>
                                        <span class="text-sm">{{ aiComment }}</span>
                                    </div>
                                    <p v-else-if="aiComment" class="text-sm md:text-base leading-7 text-base-content italic">「{{ aiComment }}」</p>
                                    <p v-else class="text-sm text-base-content/60 italic">AI分析を待機中...</p>
                                </div>
                                
                                <div class="flex flex-wrap items-center justify-between gap-4 relative">
                                    <div class="flex flex-wrap gap-2">
                                        <div v-for="tag in stats.tags" :key="tag" class="badge badge-outline badge-lg text-xs py-3 px-4 bg-base-100">
                                            # {{ tag }}
                                        </div>
                                    </div>
                                    
                                    <!-- 共有ドロップダウン -->
                                    <div class="dropdown dropdown-end">
                                        <label tabindex="0" class="btn btn-secondary gap-2 relative z-10">
                                            <i class="ph-bold ph-share-network"></i>
                                            結果を共有
                                            <i class="ph-bold ph-caret-down"></i>
                                        </label>
                                        <ul tabindex="0" class="dropdown-content menu p-2 shadow-2xl bg-base-100 rounded-box w-56 sm:w-60 mt-2 border-2 border-base-300 right-0" style="z-index: 1000 !important; position: absolute;">
                                            <li>
                                                <a @click="shareToXDirect" class="flex items-center gap-3 py-3">
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                                        <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                                                    </svg>
                                                    <div>
                                                        <div class="font-bold">Xに共有</div>
                                                        <div class="text-xs opacity-70">投稿画面を開く</div>
                                                    </div>
                                                </a>
                                            </li>
                                            <li>
                                                <a @click="shareToLine" class="flex items-center gap-3 py-3">
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="#06C755">
                                                        <path d="M19.365 9.863c.349 0 .63.285.63.631 0 .345-.281.63-.63.63H17.61v1.125h1.755c.349 0 .63.283.63.63 0 .344-.281.629-.63.629h-2.386c-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63h2.386c.346 0 .627.285.627.63 0 .349-.281.63-.63.63H17.61v1.125h1.755zm-3.855 3.016c0 .27-.174.51-.432.596-.064.021-.133.031-.199.031-.211 0-.391-.09-.51-.25l-2.443-3.317v2.94c0 .344-.279.629-.631.629-.346 0-.626-.285-.626-.629V8.108c0-.27.173-.51.43-.595.06-.023.136-.033.194-.033.195 0 .375.104.495.254l2.462 3.33V8.108c0-.345.282-.63.63-.63.345 0 .63.285.63.63v4.771zm-5.741 0c0 .344-.282.629-.631.629-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63.346 0 .628.285.628.63v4.771zm-2.466.629H4.917c-.345 0-.63-.285-.63-.629V8.108c0-.345.285-.63.63-.63.348 0 .63.285.63.63v4.141h1.756c.348 0 .629.283.629.63 0 .344-.282.629-.629.629M24 10.314C24 4.943 18.615.572 12 .572S0 4.943 0 10.314c0 4.811 4.27 8.842 10.035 9.608.391.082.923.258 1.058.59.12.301.079.766.038 1.08l-.164 1.02c-.045.301-.24 1.186 1.049.645 1.291-.539 6.916-4.078 9.436-6.975C23.176 14.393 24 12.458 24 10.314"/>
                                                    </svg>
                                                    <div>
                                                        <div class="font-bold">LINEで共有</div>
                                                        <div class="text-xs opacity-70">テキストで送信</div>
                                                    </div>
                                                </a>
                                            </li>
                                            <div class="divider my-1"></div>
                                            <li>
                                                <a @click="copyResultText" class="flex items-center gap-3 py-3">
                                                    <i class="ph-bold ph-copy text-xl"></i>
                                                    <div>
                                                        <div class="font-bold">テキストをコピー</div>
                                                        <div class="text-xs opacity-70">SNS投稿用</div>
                                                    </div>
                                                </a>
                                            </li>
                                            <li>
                                                <a @click="downloadCard" class="flex items-center gap-3 py-3">
                                                    <i class="ph-bold ph-download-simple text-xl"></i>
                                                    <div>
                                                        <div class="font-bold">画像をダウンロード</div>
                                                        <div class="text-xs opacity-70">PNG形式で保存</div>
                                                    </div>
                                                </a>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-2 lg:grid-cols-4 gap-4">
                    <div v-for="m in stats.mainMetrics" :key="m.label" class="card bg-base-100 shadow-lg">
                        <div class="card-body p-5">
                            <div class="text-xs text-base-content/60 font-bold uppercase tracking-wide">{{ m.label }}</div>
                            <div class="text-3xl font-black text-primary mt-1">{{ m.value }}</div>
                            <div class="text-xs text-base-content/70 mt-2">{{ m.sub }}</div>
                        </div>
                    </div>
                </div>

                <div class="card bg-base-100 shadow-lg">
                    <div class="card-body p-6">
                        <h3 class="text-lg font-bold mb-4 flex items-center gap-2">
                            <i class="ph-fill ph-chart-polar text-secondary"></i> ジャンル適合度レーダー
                        </h3>
                        <div class="h-[320px] relative">
                            <canvas id="radarChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="grid lg:grid-cols-2 gap-6">
                    <div class="card bg-base-100 shadow-lg">
                        <div class="card-body p-6">
                            <h3 class="text-lg font-bold mb-3 flex items-center gap-2">
                                <i class="ph-fill ph-heartbeat text-pink-500"></i> 感情トーン推移
                            </h3>
                            <div class="h-[200px]">
                                <canvas id="sentimentChart"></canvas>
                            </div>
                            <div class="text-xs mt-3 opacity-70 text-center">
                                テキスト全体を通しての感情の起伏を可視化
                            </div>
                        </div>
                    </div>

                    <div class="card bg-base-100 shadow-lg">
                        <div class="card-body p-6">
                            <h3 class="text-lg font-bold mb-3 flex items-center gap-2">
                                <i class="ph-fill ph-text-aa text-blue-500"></i> 文末パターン分析
                            </h3>
                            <div class="space-y-2">
                                <div v-for="(ep, idx) in stats.contentMetrics.endingPatterns" :key="idx" class="flex items-center gap-3">
                                    <div class="flex-1">
                                        <div class="flex justify-between text-sm mb-1">
                                            <span class="font-mono">{{ ep.pattern }}</span>
                                            <span class="font-bold">{{ ep.count }}回 ({{ ep.percentage.toFixed(1) }}%)</span>
                                        </div>
                                        <div class="w-full bg-base-200 rounded-full h-2">
                                            <div class="bg-gradient-to-r from-blue-500 to-purple-500 h-2 rounded-full transition-all" :style="{width: ep.percentage + '%'}"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-3 text-xs">
                                <span class="badge badge-sm" :class="stats.contentMetrics.endingVariety >= 70 ? 'badge-success' : stats.contentMetrics.endingVariety >= 50 ? 'badge-warning' : 'badge-error'">
                                    バリエーション: {{ stats.contentMetrics.endingVariety.toFixed(0) }}点
                                </span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="card bg-base-100 shadow-lg">
                    <div class="card-body p-6">
                        <h3 class="text-lg font-bold mb-4 flex items-center gap-2">
                            <i class="ph-fill ph-brain text-purple-500"></i> 詳細品質分析
                        </h3>
                        <div class="grid md:grid-cols-2 gap-4">
                            <div v-for="qm in stats.qualityMetrics" :key="qm.label" class="bg-base-200/50 p-4 rounded-xl">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-bold text-sm">{{ qm.label }}</span>
                                    <span class="badge" :class="getScoreBg(qm.score)">{{ qm.score }}点</span>
                                </div>
                                <div class="w-full bg-base-300 rounded-full h-2">
                                    <div class="h-2 rounded-full transition-all" :class="getScoreColor(qm.score)" :style="{width: qm.score + '%'}"></div>
                                </div>
                                <div class="text-xs mt-2 text-base-content/70">{{ qm.comment }}</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="card bg-base-100 shadow-lg border-l-4 border-warning">
                    <div class="card-body p-6">
                        <h3 class="text-lg font-bold mb-4 flex items-center gap-2">
                            <i class="ph-fill ph-lightbulb text-warning"></i> 改善アドバイス
                        </h3>
                        <div class="space-y-3">
                            <div v-for="(advice, idx) in adviceList" :key="idx" class="alert shadow-sm bg-base-200/50">
                                <div class="flex-1">
                                    <div class="flex items-center justify-between mb-1">
                                        <span class="font-bold text-sm">{{ advice.label }}</span>
                                        <span class="badge badge-sm" :class="advice.statusBadge">{{ advice.value }}</span>
                                    </div>
                                    <div class="text-xs opacity-80">
                                        <span class="text-base-content/50">目標:</span> {{ advice.target }} 
                                        <span class="ml-2">→</span> {{ advice.msg }}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </section>
    </main>

    <!-- 固定解析ボタン -->
    <div class="fixed bottom-0 left-0 right-0 z-40 bg-base-100/95 backdrop-blur-md border-t border-base-300 shadow-2xl fixed-button-bar">
        <div class="max-w-7xl mx-auto p-3 md:p-4">
            <div class="flex items-center justify-center gap-3 md:gap-4 flex-wrap">
                <!-- AIモードトグル -->
                <label class="flex items-center gap-2 cursor-pointer">
                    <input type="checkbox" v-model="isAIMode" class="toggle toggle-primary toggle-sm md:toggle-md" />
                    <span class="text-xs md:text-sm font-bold flex items-center gap-1.5">
                        <i class="ph-fill ph-robot text-base md:text-lg"></i>
                        <span class="hidden sm:inline">AIモード</span>
                    </span>
                </label>
                
                <!-- 分析ボタン -->
                <button @click="analyzeText" class="btn btn-secondary btn-md md:btn-lg gap-2 shadow-lg min-w-[200px] md:min-w-[280px]" :disabled="inputText.length < 100">
                    <i class="ph-bold ph-magnifying-glass text-lg md:text-xl"></i>
                    <span class="font-bold">分析開始</span>
                    <span v-if="inputText.length < 100" class="text-xs opacity-70 hidden md:inline">(あと{{ 100 - inputText.length }}文字)</span>
                    <span v-else class="badge badge-success text-xs">{{ inputText.length.toLocaleString() }}</span>
                </button>
            </div>
        </div>
    </div>

    <div v-if="toastMessage" class="toast toast-top toast-center z-[100] animate-bounce-in">
        <div class="alert shadow-lg" :class="toastType">
            <i :class="toastIcon" class="text-xl"></i>
            <span class="font-bold">{{ toastMessage }}</span>
        </div>
    </div>

    <!-- AI利用規約モーダル -->
    <div v-if="showAITermsModal" class="fixed inset-0 z-[200] flex items-center justify-center bg-black/60 backdrop-blur-sm animate-fade-in-up">
        <div class="bg-base-100 rounded-2xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-hidden flex flex-col">
            <div class="p-6 border-b border-base-300">
                <h2 class="text-2xl font-bold flex items-center gap-3">
                    <i class="ph-fill ph-warning-circle text-warning text-3xl"></i>
                    AIモード利用規約
                </h2>
            </div>
            
            <div class="p-6 overflow-y-auto flex-1 space-y-4 text-sm leading-relaxed">
                <div class="alert alert-warning">
                    <i class="ph-fill ph-info text-xl"></i>
                    <div class="text-sm">
                        <strong>重要：</strong>AIモードをご利用になる前に、以下の利用規約を必ずお読みください。
                    </div>
                </div>

                <div class="space-y-3">
                    <h3 class="font-bold text-base flex items-center gap-2">
                        <i class="ph-fill ph-one text-primary"></i>
                        データの外部送信について
                    </h3>
                    <p class="pl-7 text-base-content/80">
                        AIモードを有効にすると、入力された本文（最大2000文字）が外部のAI API（Hugging Face）に送信されます。送信されたデータは、AI による分析と感想生成にのみ使用されます。
                    </p>
                </div>

                <div class="space-y-3">
                    <h3 class="font-bold text-base flex items-center gap-2">
                        <i class="ph-fill ph-two text-primary"></i>
                        免責事項
                    </h3>
                    <ul class="pl-7 space-y-2 text-base-content/80 list-disc list-inside">
                        <li>本サービスは、送信されたデータの安全性、機密性、完全性について一切の責任を負いません。</li>
                        <li>機密情報、個人情報、未公開作品など、外部に送信したくない内容は入力しないでください。</li>
                        <li>AI APIの利用により発生したいかなる損害についても、本サービスは責任を負いません。</li>
                        <li>AIによる評価や感想は参考情報であり、正確性を保証するものではありません。</li>
                    </ul>
                </div>

                <div class="space-y-3">
                    <h3 class="font-bold text-base flex items-center gap-2">
                        <i class="ph-fill ph-three text-primary"></i>
                        データの取り扱い
                    </h3>
                    <p class="pl-7 text-base-content/80">
                        送信されたデータは、外部AI APIのプロバイダーの利用規約およびプライバシーポリシーに従って処理されます。本サービスは、外部APIプロバイダーによるデータの保存、使用、共有について制御することはできません。
                    </p>
                </div>

                <div class="space-y-3">
                    <h3 class="font-bold text-base flex items-center gap-2">
                        <i class="ph-fill ph-four text-primary"></i>
                        ユーザーの責任
                    </h3>
                    <p class="pl-7 text-base-content/80">
                        AIモードを使用することにより、ユーザーは上記の内容を理解し、データ送信に伴うリスクを承諾したものとみなされます。著作権、プライバシー権、その他の権利を侵害する内容を送信しないでください。
                    </p>
                </div>

                <div class="alert alert-info mt-4">
                    <i class="ph-fill ph-lightbulb text-xl"></i>
                    <div class="text-sm">
                        <strong>推奨：</strong>個人情報や機密情報を含まない、公開予定またはサンプルテキストでのご利用をお勧めします。
                    </div>
                </div>
            </div>

            <div class="p-6 border-t border-base-300 flex gap-3">
                <button @click="declineAITerms" class="btn btn-ghost flex-1">
                    <i class="ph-bold ph-x"></i>
                    同意しない
                </button>
                <button @click="acceptAITerms" class="btn btn-primary flex-1">
                    <i class="ph-bold ph-check"></i>
                    同意してAIモードを有効化
                </button>
            </div>
        </div>
    </div>

    <!-- 共有カード生成用（画面外に配置） -->
    <div id="shareCard" style="position: fixed; left: -9999px; top: 0;">
        <div style="width: 800px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px; font-family: 'Zen Maru Gothic', sans-serif;">
            <div style="background: white; border-radius: 24px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                <!-- ヘッダー -->
                <div style="text-align: center; margin-bottom: 30px;">
                    <h1 style="font-size: 32px; font-weight: 900; color: #667eea; margin: 0 0 8px 0;">私の小説戦闘力</h1>
                    <p style="font-size: 16px; color: #64748b; margin: 0;" id="cardGenre">恋愛（異世界）</p>
                </div>
                
                <!-- ランク表示 -->
                <div style="text-align: center; margin-bottom: 30px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 20px; padding: 30px;">
                    <div style="font-size: 100px; font-weight: 900; line-height: 1; color: white; margin: 0;" id="cardRank">B</div>
                    <div style="font-size: 32px; font-weight: 700; color: rgba(255,255,255,0.9); margin-top: 5px;" id="cardScore">65.0<span style="font-size: 18px;">/100</span></div>
                </div>
                
                <!-- レーダーチャート -->
                <div style="margin-bottom: 30px; background: #f8fafc; border-radius: 16px; padding: 20px;">
                    <canvas id="cardRadarChart" width="720" height="400"></canvas>
                </div>
                
                <!-- AIコメント -->
                <div id="cardAICommentSection" style="background: linear-gradient(135deg, #fdf4ff 0%, #fae8ff 100%); padding: 24px; border-radius: 16px; margin-bottom: 20px; border: 2px solid #e9d5ff; display: none;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                        <span style="font-size: 20px;">💜</span>
                        <h3 style="font-size: 16px; font-weight: 700; color: #7c3aed; margin: 0;">AI読後感想</h3>
                    </div>
                    <p id="cardAIComment" style="font-size: 15px; line-height: 1.7; color: #1f2937; margin: 0; font-style: italic;">「素晴らしい作品です！」</p>
                </div>
                
                <!-- フッター -->
                <div style="text-align: center; padding-top: 20px; border-top: 2px solid #e2e8f0;">
                    <p style="font-size: 18px; font-weight: 700; color: #475569; margin: 0 0 4px 0;">Narou Analyzer Ultra3.2</p>
                    <p style="font-size: 12px; color: #94a3b8; margin: 0;">#なろうアナライザー</p>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
const { createApp, ref, computed, watch, onMounted, nextTick } = Vue;

createApp({
    setup() {
        const inputText = ref('');
        const selectedGenre = ref('love_isekai');
        const isProcessing = ref(false);
        const stats = ref(null);
        const adviceList = ref([]);
        const isDarkMode = ref(false);
        const toastMessage = ref('');
        const toastType = ref('');
        const toastIcon = ref('');
        const isAIMode = ref(false);
        const aiComment = ref('');
        const isAIProcessing = ref(false);
        const showAITermsModal = ref(false);
        const hasAgreedToAITerms = ref(false);

        let radarChart = null;
        let sentimentChart = null;

        const scoringProfiles = {
          love_isekai: {
    name: '恋愛（異世界）',
    desc: '恋愛を主題とし、異世界を主な舞台とした作品。',
    targetLen: 48,
    minDialog: 42,
    weights: { vocab: 1.4, description: 1.5, dialogue: 1.5, sentiment: 1.4, ending: 1.6, viewpoint: 1.2, tempo: 1.3, redundancy: 1.2, connector: 1.1, keyword: 1.4 },
    keywords: '恋|愛|心|想い|気持ち|好き|嫌い|切ない|胸|ドキドキ|見つめ|笑顔|涙|抱き|手|唇|キス|告白|異世界|魔法|転生|冒険|' +
              '高鳴|鼓動|ときめき|焦がれ|熱|温もり|冷た|震え|赤面|頬|染め|視線|瞳|交わ|触れ|指先|髪|撫で|腰|背中|吐息|息遣い|香り|匂い|甘い|苦しい|辛い|嫉妬|独占|羨望|軽蔑|侮蔑|絶望|希望|信頼|裏切り|許し|誓い|永遠|運命|絆|予感|直感|戸惑い|躊躇|覚悟|決意|安らぎ|幸福|幸せ|不幸せ|哀れ|惨め|誇り|プライド|狂気|執着|依存|純愛|初恋|失恋|未練|復縁|両片思い|すれ違い|身分差|政略|契約|偽装|真実|嘘|秘密|噂|誤解|' +
              '私|俺|僕|貴方|君|お前|彼|彼女|少女|少年|令嬢|淑女|紳士|王子|王太子|殿下|陛下|王|王妃|側室|公爵|侯爵|伯爵|子爵|男爵|辺境伯|騎士|団長|宰相|側近|従者|執事|メイド|侍女|教育係|家庭教師|聖女|巫女|女神|神|精霊|魔王|勇者|冒険者|ギルド|受付|商人|平民|奴隷|ヒロイン|悪役|悪役令嬢|取り巻き|ライバル|当て馬|モブ|転生者|憑依|トリップ|' +
              '出会い|再会|別れ|婚約|結婚|婚姻|求婚|プロポーズ|破棄|解消|断罪|追放|処刑|監禁|軟禁|離縁|離婚|初夜|寵愛|溺愛|愛され|冷遇|虐げ|放置|ざまぁ|ザマァ|逆転|成り上がり|チート|無双|スキル|ステータス|レベル|鑑定|アイテム|ポーション|ドレス|宝石|舞踏会|夜会|パーティー|お茶会|サロン|学園|授業|図書室|バルコニー|庭園|教会|大聖堂|神殿|ダンジョン|森|王都|スローライフ|開拓|料理|薬草|もふもふ|乙女ゲーム|シナリオ|フラグ|ルート|攻略|バッドエンド|ハッピーエンド|前世|記憶|知識|現代|日本'
},
            love_real: {
    name: '恋愛（現実世界）',
    desc: '恋愛を主題とし、現実に近しい世界を舞台とした作品。',
    targetLen: 45,
    minDialog: 45,
    weights: { vocab: 1.4, description: 1.5, dialogue: 1.6, sentiment: 1.5, ending: 1.7, viewpoint: 1.2, tempo: 1.3, redundancy: 1.2, connector: 1.2, keyword: 1.3 },
    keywords: '恋|愛|心|想い|気持ち|好き|嫌い|切ない|胸|ドキドキ|見つめ|笑顔|涙|抱き|手|唇|キス|告白|デート|学校|仕事|日常|' +
              '高鳴|鼓動|ときめき|熱|温もり|冷た|震え|赤面|頬|染め|視線|瞳|指先|髪|撫で|腰|背中|吐息|息遣い|香り|匂い|甘い|苦しい|辛い|嫉妬|独占|焦|不安|期待|絶望|希望|信頼|裏切り|誓い|運命|絆|予感|直感|戸惑い|躊躇|覚悟|安らぎ|幸福|幸せ|狂気|執着|依存|純愛|初恋|失恋|未練|復縁|両片思い|すれ違い|片思い|秘密|嘘|誤解|駆け引き|' +
              '私|俺|僕|貴方|君|お前|彼|彼女|彼氏|元カレ|元カノ|幼馴染|先輩|後輩|同級生|先生|上司|部下|同僚|社長|秘書|夫婦|妻|夫|旦那|嫁|婚約者|パートナー|セフレ|ライバル|友人|親友|家族|兄弟|姉妹|' +
              '教室|授業|放課後|部活|マネージャー|朝練|合宿|制服|リボン|ネクタイ|ブレザー|セーラー|席|隣|廊下|屋上|体育館|グラウンド|図書室|保健室|テスト|試験|勉強|受験|塾|文化祭|体育祭|修学旅行|卒業|入学|クラス|夏休み|冬休み|春休み|' +
              '会社|職場|オフィス|残業|定時|有給|出張|転勤|就職|転職|退職|飲み会|接待|スーツ|名刺|給料|ボーナス|ブラック|ホワイト|会議|プレゼン|営業|事務|' +
              'スマホ|携帯|iPhone|LINE|ライン|LINE|メール|電話|通話|メッセージ|既読|未読|返信|着信|通知|ブロック|スタンプ|SNS|ツイッター|インスタ|写真|動画|アプリ|ゲーム|画面|充電|' +
              '家|部屋|鍵|アパート|マンション|同棲|一人暮らし|実家|玄関|リビング|ソファ|ベッド|布団|枕|キッチン|料理|ご飯|エプロン|お風呂|シャワー|洗面所|歯ブラシ|パジャマ|ベランダ|洗濯|掃除|スーパー|コンビニ|駅|電車|満員|バス|改札|定期|車|ドライブ|助手席|信号|渋滞|' +
              'クリスマス|イブ|バレンタイン|ホワイトデー|チョコ|誕生日|バースデー|プレゼント|ケーキ|花束|指輪|アクセサリー|遊園地|テーマパーク|観覧車|映画|水族館|動物園|海|プール|花火|祭り|浴衣|神社|初詣|お守り|カラオケ|カフェ|喫茶店|レストラン|居酒屋|バー|ホテル|ラブホ|公園|ベンチ|夜景|イルミネーション|お見合い|婚活|合コン|街コン|マッチング|ナンパ|浮気|不倫|離婚|再婚'
},
         fantasy_high: {
    name: 'ハイファンタジー',
    desc: '現実世界とは異なる世界を主な舞台とした作品。',
    targetLen: 55,
    minDialog: 35,
    weights: { vocab: 1.5, description: 1.6, dialogue: 1.3, sentiment: 1.2, ending: 1.6, viewpoint: 1.2, tempo: 1.3, redundancy: 1.2, connector: 1.2, keyword: 1.5 },
    keywords: '魔法|魔術|剣|冒険|ドラゴン|エルフ|ドワーフ|魔王|勇者|王国|城|ダンジョン|モンスター|スキル|レベル|異世界|転生|' +
              'ステータス|能力値|鑑定|アイテムボックス|収納|インベントリ|ランク|パーティ|クエスト|依頼|ギルド|報酬|素材|魔石|解体|金貨|銀貨|銅貨|物価|市場|行商|' +
              '召喚|転移|憑依|チート|無双|最強|最弱|底辺|追放|ざまぁ|復讐|逆転|成り上がり|覚醒|進化|成長|修行|師匠|弟子|天才|凡人|劣等|' +
              '火|水|風|土|雷|氷|光|闇|聖|無|属性|相性|詠唱|無詠唱|魔力|マナ|MP|HP|回復|治癒|ポーション|結界|付与|エンチャント|呪い|デバフ|バフ|' +
              '攻撃|防御|回避|斬撃|刺突|打撃|武技|奥義|必殺|剣聖|剣豪|聖剣|魔剣|盾|鎧|ローブ|杖|ダガー|槍|弓|矢|' +
              '魔物|ゴブリン|オーク|スライム|ウルフ|オーガ|ワイバーン|キメラ|アンデッド|スケルトン|ゾンビ|リッチ|ヴァンパイア|悪魔|天使|神|女神|精霊|妖精|獣人|魔族|' +
              '帝国|皇国|公国|辺境|領地|領主|貴族|平民|奴隷|商会|神殿|教会|聖女|賢者|魔導師|騎士|団長|衛兵|盗賊|暗殺者|ネクロマンサー|テイマー|召喚士|錬金術|鍛冶|' +
              '迷宮|深層|階層|ボス|宝箱|トラップ|罠|野営|キャンプ|森|洞窟|荒野|遺跡|塔|海|空|戦場|戦争|軍|戦略|戦術|勝利|敗北|全滅|撤退|' +
              '伝説|神話|歴史|古代|文明|遺物|アーティファクト|禁忌|封印|解放|契約|従魔|使い魔|相棒|仲間|裏切り|信頼|絆|運命|世界|覇権'
},
          fantasy_low: {
    name: 'ローファンタジー',
    desc: '現実世界に近しい世界にファンタジー要素を取り入れた作品。',
    targetLen: 50,
    minDialog: 40,
    weights: { vocab: 1.4, description: 1.4, dialogue: 1.4, sentiment: 1.3, ending: 1.7, viewpoint: 1.2, tempo: 1.3, redundancy: 1.2, connector: 1.2, keyword: 1.3 },
    keywords: '不思議|異世界|能力|魔法|幽霊|妖怪|神|現代|日常|学校|街|普通|特別|現実|' +
              'ダンジョン|迷宮|ゲート|穴|発生|出現|スタンピード|アウトブレイク|氾濫|崩壊|モンスター|魔物|オーク|ゴブリン|スライム|ドラゴン|素材|魔石|ドロップ|換金|買取|円|億|借金|返済|協会|ギルド|管理|政府|自衛隊|警察|特殊|対策|課|庁|ライセンス|証|ランク|等級|S級|最弱|最強|探索|シーカー|探索者|ハンター|攻略|' +
              'ステータス|スキル|レベル|鑑定|アイテム|インベントリ|ボックス|収納|ショップ|ガチャ|ポイント|課金|ログ|通知|ウィンドウ|システム|ボード|画面|表示|覚醒|進化|固有|ユニーク|天与|チート|無双|隠蔽|隠す|正体|' +
              '配信|動画|生放送|ライブ|チャンネル|登録|同接|視聴|リスナー|コメント|スパチャ|投げ銭|収益|広告|バズ|炎上|祭り|特定|晒し|掲示板|スレ|SNS|ツイッター|トレンド|拡散|アンチ|信者|有名|人気|インフルエンサー|VTuber|ストリーマー|ドローン|カメラ|' +
              '陰陽|退魔|除霊|祓|呪い|霊|悪霊|怨霊|あやかし|怪異|オカルト|都市伝説|神社|鳥居|寺|結界|術|式神|巫女|霊能|超能力|エスパー|サイキック|異能|学園|生徒会|抗争|' +
              '帰還|逆行|再会|転移|招喚|干渉|侵食|東京|日本|新宿|渋谷|ダンジョンおじさん|スマホ|ニュース|緊急|速報|警報|避難|日常|パニック|マンション|アパート|コンビニ|スーパー|バイト|社畜|ブラック|残業|会社|辞表|退職'
},
            literary_pure: {
    name: '純文学',
    desc: '芸術性に重きを置いた作品。',
    targetLen: 70,
    minDialog: 20,
    weights: { vocab: 1.8, description: 1.7, dialogue: 1.1, sentiment: 1.4, ending: 1.8, viewpoint: 1.4, tempo: 1.1, redundancy: 1.5, connector: 1.4, keyword: 1.0 },
    keywords: '心|魂|生|死|時間|記憶|意識|存在|孤独|沈黙|風景|影|光|美|芸術|' +
              '憂鬱|虚無|焦燥|葛藤|矛盾|諦念|哀しみ|嘆き|慈しみ|憐れみ|安らぎ|苦悩|絶望|希望|幸福|不幸|罪|罰|倫理|道徳|真理|哲学|宗教|神|悪魔|人間|自我|エゴ|無意識|深層|夢|現|幻|幻想|妄想|狂気|正気|理性|感性|本能|衝動|情動|愛憎|嫉妬|羨望|侮蔑|軽蔑|尊厳|恥|誇り|' +
              '雨|風|雪|雲|霧|霞|雷|嵐|空|海|波|凪|潮|川|水|雫|滴|月|星|太陽|陽射し|木漏れ日|夕暮れ|黄昏|夜明け|黎明|朝|昼|夕|夜|深夜|未明|季節|春|夏|秋|冬|桜|花|樹木|枯葉|落葉|蝉|鳥|虫|蝶|獣|猫|犬|金魚|' +
              '静寂|静謐|喧騒|雑踏|路地|坂道|石畳|アスファルト|コンクリート|壁|窓|ガラス|鏡|カーテン|部屋|鍵|扉|廊下|階段|屋根|天井|床|畳|襖|障子|庭|縁側|アパート|団地|駅|線路|踏切|電車|バス|街灯|公園|ベンチ|ブランコ|' +
              '色|匂い|香り|音|声|響き|肌|触感|手触り|温度|熱|冷気|温もり|痛み|傷|痕|血|骨|灰|墓|葬儀|喪服|遺影|線香|煙草|紫煙|灰皿|酒|グラス|ボトル|珈琲|紅茶|本|書物|活字|インク|ペン|手紙|日記|写真|' +
              '永遠|刹那|瞬間|無限|有限|境界|彼岸|此岸|深淵|奈落|浮遊|沈殿|消失|消滅|崩壊|再生|輪廻|運命|偶然|必然|日常|非日常|社会|世間|他人|家族|父|母|兄|姉|弟|妹|祖父|祖母|友人|恋人|別れ|再会|喪失|欠落|空虚'
},
           literary_human: {
    name: 'ヒューマンドラマ',
    desc: '人と人との交流、人の一生、人間らしさ等を主題とした作品。',
    targetLen: 55,
    minDialog: 40,
    weights: { vocab: 1.5, description: 1.5, dialogue: 1.5, sentiment: 1.4, ending: 1.3, viewpoint: 1.3, tempo: 1.2, redundancy: 1.3, connector: 1.3, keyword: 1.2 },
    keywords: '人生|家族|友情|絆|別れ|出会い|成長|葛藤|決断|後悔|希望|愛|人間|心|感情|' +
              '父|母|パパ|ママ|お父さん|お母さん|親父|お袋|祖父|祖母|じいちゃん|ばあちゃん|息子|娘|兄弟|姉妹|兄|弟|姉|妹|孫|親戚|叔父|叔母|従兄弟|義父|義母|夫婦|夫|妻|嫁|姑|婿|親子|家庭|一家|団欒|独り|' +
              '友人|親友|幼馴染|仲間|相棒|隣人|恩師|先生|生徒|同僚|上司|部下|先輩|後輩|他人|世間|社会|地域|故郷|田舎|都会|近所|路地|商店街|公園|病院|学校|職場|' +
              '誕生|産声|妊娠|出産|赤ちゃん|子供|大人|老人|高齢|寿命|死|他界|葬式|葬儀|墓|仏壇|遺影|法事|遺産|相続|介護|認知症|車椅子|入院|手術|退院|見舞い|健康|病気|怪我|障害|リハビリ|' +
              '結婚|離婚|再婚|婚活|見合い|別居|同居|里帰り|帰省|家出|反抗期|初恋|失恋|喧嘩|仲直り|謝罪|許し|感謝|ありがとう|ごめん|涙|泣き|笑顔|笑い声|怒り|叫び|抱擁|握手|温もり|' +
              '仕事|就職|退職|定年|リストラ|失業|貧乏|借金|裕福|成功|失敗|挫折|夢|目標|現実|平凡|特別|才能|努力|苦労|給料|生活|暮らし|家計|節約|贅沢|' +
              '食事|ご飯|朝食|昼食|夕食|晩酌|弁当|おにぎり|味噌汁|カレー|肉じゃが|手料理|味|匂い|湯気|食卓|箸|茶碗|台所|キッチン|スーパー|買い物|値引き|' +
              '春|夏|秋|冬|桜|海|紅葉|雪|正月|大晦日|クリスマス|盆|祭り|花火|誕生日|記念日|プレゼント|手紙|写真|アルバム|思い出|記憶|過去|未来|現在|時間|時計|日記|約束|秘密|嘘|真実|信頼|裏切り|誤解'
},
           literary_history: {
    name: '歴史',
    desc: '過去を舞台にした作品。時代小説、タイムトラベルものを含む。',
    targetLen: 60,
    minDialog: 30,
    weights: { vocab: 1.7, description: 1.5, dialogue: 1.3, sentiment: 1.2, ending: 1.2, viewpoint: 1.3, tempo: 1.2, redundancy: 1.3, connector: 1.3, keyword: 1.4 },
    keywords: '侍|武士|武将|兵|軍勢|騎馬|刀|剣|槍|弓|鉄砲|火縄銃|甲冑|鎧|兜|城|天守|石垣|堀|殿|主君|家臣|郎党|姫|奥方|側室|将軍|大名|公方|幕府|朝廷|帝|天皇|公家|関白|太閤|執権|戦|合戦|戦場|陣|本陣|首|天下|統一|野望|覇権|江戸|京|都|大坂|鎌倉|室町|安土|戦国|乱世|泰平|明治|大正|維新|幕末|新選組|志士|浪人|牢人|忍者|忍び|間者|草|百姓|農民|町人|商人|職人|長屋|屋敷|遊郭|吉原|花魁|遊女|芸者|茶屋|旅籠|宿場|街道|関所|忠義|忠誠|裏切り|謀反|下克上|切腹|介錯|仇討ち|成敗|処刑|武士道|義理|人情|面目|恥|誉れ|家名|跡継ぎ|養子|政略|一揆|参勤交代|年貢|石高|米|酒|茶|着物|袴|帯|髷|刀傷|血|歴史|時代|過去|未来|現代|タイムスリップ|タイムトラベル|転移|逆行|改変|史実|正史|IF|知識|内政|改革|西洋|黒船|開国|攘夷'
},
         literary_mystery: {
    name: '推理',
    desc: '事件等を推理し、謎解きを行う過程を主体とした作品。',
    targetLen: 55,
    minDialog: 35,
    weights: { vocab: 1.5, description: 1.5, dialogue: 1.4, sentiment: 1.2, ending: 1.3, viewpoint: 1.4, tempo: 1.3, redundancy: 1.4, connector: 1.5, keyword: 1.3 },
    keywords: '事件|殺人|犯人|推理|証拠|アリバイ|トリック|謎|手がかり|捜査|刑事|探偵|真相|犯罪|' +
              '死体|遺体|被害者|加害者|容疑者|参考人|目撃者|共犯|黒幕|真犯人|愉快犯|サイコパス|ストーカー|遺族|冤罪|名探偵|助手|ワトソン|警部|警視|鑑識|検死|解剖|弁護士|検事|警察|公安|組織|' +
              '現場|保存|検証|規制線|聞き込み|張り込み|尾行|事情聴取|取り調べ|自供|黙秘|否認|自首|逮捕|令状|時効|未解決|コールドケース|' +
              '密室|クローズドサークル|孤島|洋館|嵐|雪山|山荘|地下室|屋根裏|廃墟|鍵|施錠|抜け道|隠し通路|' +
              '刺殺|絞殺|毒殺|撲殺|銃殺|溺死|焼死|自殺|他殺|事故|病死|偽装|工作|見立て|バラバラ|猟奇|連続|誘拐|脅迫|人質|身代金|強盗|窃盗|放火|' +
              '凶器|ナイフ|拳銃|ロープ|毒|青酸カリ|薬物|睡眠薬|指紋|足跡|血痕|ルミノール|DNA|毛髪|硝煙|唾液|歯型|死亡推定時刻|死因|' +
              '動機|怨恨|復讐|嫉妬|痴情|金銭|借金|遺産|保険金|口封じ|突発|計画|衝動|正当防衛|緊急避難|殺意|悪意|' +
              '論理|ロジック|演繹|帰納|消去法|矛盾|破綻|嘘|心理|観察|洞察|違和感|直感|仮説|証明|論破|指摘|暴く|解明|解決|' +
              '伏線|回収|ミスリード|叙述|どんでん返し|暗号|ダイイングメッセージ|予告状|挑戦状|不在証明|入替え|双子|変装|指名手配|防犯カメラ|通話履歴|GPS|SNS|拡散'
},
            literary_horror: {
    name: 'ホラー',
    desc: '読者に恐怖感を与えることを主題とした作品。',
    targetLen: 50,
    minDialog: 30,
    weights: { vocab: 1.4, description: 1.7, dialogue: 1.2, sentiment: 1.5, ending: 1.4, viewpoint: 1.3, tempo: 1.4, redundancy: 1.2, connector: 1.2, keyword: 1.3 },
    keywords: '恐怖|怖い|不気味|闇|影|血|死|叫び|悲鳴|震え|心臓|背筋|冷や汗|幽霊|怪異|呪い|' +
              '暗闇|漆黒|深夜|丑三つ時|夜道|街灯|点滅|停電|霧|雨|嵐|雷|静寂|無音|耳鳴り|異臭|腐臭|生臭い|カビ|埃|廃墟|廃屋|事故物件|トンネル|病院|学校|トイレ|鏡|井戸|隙間|押し入れ|ベッドの下|地下室|屋根裏|廊下|階段|エレベーター|' +
              '悪寒|鳥肌|戦慄|パニック|錯乱|狂気|発狂|正気|幻覚|幻聴|妄想|悪夢|金縛り|麻痺|呼吸|過呼吸|息切れ|動悸|鼓動|激痛|苦痛|吐き気|嘔吐|失禁|気絶|呆然|凝視|硬直|' +
              '視線|気配|足音|物音|ノック|ラップ音|軋む|開く|閉まる|覗く|見つめる|追いかける|逃げる|隠れる|迫る|這う|掴む|触れる|撫でる|囁く|笑う|泣く|睨む|' +
              '怨霊|悪霊|生霊|地縛霊|浮遊霊|亡霊|死神|悪魔|妖怪|化け物|怪物|異形|人外|鬼|ゾンビ|殺人鬼|サイコパス|ストーカー|異常者|隣人|子供|女|老婆|人形|日本人形|仮面|ピエロ|' +
              '鮮血|血飛沫|肉|骨|内臓|死体|遺体|白骨|腐敗|切断|首|目玉|髪|長い髪|爪|牙|傷|痕|痣|火傷|ミイラ|' +
              '都市伝説|噂|怪談|百物語|肝試し|心霊|スポット|写真|動画|配信|ノイズ|バグ|文字化け|スマホ|着信|非通知|メッセージ|チェーンメール|掲示板|儀式|降霊|コックリさん|ひとりかくれんぼ|' +
              '殺害|殺意|恨み|憎悪|復讐|祟り|因縁|厄災|不吉|予言|警告|タブー|禁忌|封印|結界|お札|お守り|塩|神社|寺|墓|墓地|霊園|葬式|線香|仏壇'
},
           literary_action: {
    name: 'アクション',
    desc: '戦闘描写、アクションシーンを主体とした作品。',
    targetLen: 30,
    minDialog: 30,
    weights: { vocab: 1.3, description: 1.5, dialogue: 1.3, sentiment: 1.2, ending: 1.4, viewpoint: 1.2, tempo: 1.6, redundancy: 1.3, connector: 1.2, keyword: 1.3 },
    keywords: '戦い|攻撃|防御|剣|銃|爆発|疾走|跳躍|回避|一撃|必殺|倒す|敵|バトル|戦闘|' +
              '殴|蹴|斬|刺|撃|射|投|飛|走|駆|受|避|豨|弾|防|殺|壊|砕|裂|穿|貫|断|捻|絞|伏|隠|構|狙|' +
              '拳|足|脚|肘|膝|指|爪|牙|頭|首|喉|心臓|腹|背|腕|肩|脇|急所|死角|隙|正中線|動体視力|反射神経|' +
              '刀|刃|槍|斧|槌|盾|鎧|兜|ナイフ|ダガー|クナイ|手裏剣|暗器|弓|矢|クロスボウ|弾丸|マガジン|トリガー|銃口|照準|スコープ|ライフル|マシンガン|ハンドガン|散弾|砲撃|爆弾|手榴弾|地雷|ミサイル|レーザー|兵器|' +
              '連撃|乱舞|カウンター|相打ち|鍔迫り合い|フェイント|牽制|特攻|奇襲|強襲|迎撃|包囲|突破|撤退|追撃|乱戦|消耗戦|総力戦|決戦|一騎打ち|タイマン|' +
              '衝撃|反動|轟音|爆音|金属音|火花|閃光|硝煙|砂煙|血煙|土煙|粉塵|残像|風圧|殺気|闘気|覇気|威圧|プレッシャー|アドレナリン|興奮|狂乱|覚醒|' +
              '激痛|鈍痛|痺れ|出血|吐血|骨折|打撲|裂傷|瀕死|即死|満身創痍|限界|疲労|息切れ|過呼吸|冷や汗|脂汗|震え|硬直|気絶|意識|生存|死亡|' +
              '勝負|勝利|敗北|決着|優勢|劣勢|逆転|油断|慢心|本気|全力|底力|奥義|秘技|スキル|能力|チート|無双|最強|最速|怪物|化け物|強者|弱者|獲物|狩り|戦場|修羅場'
},
           literary_comedy: {
    name: 'コメディー',
    desc: '読者を笑わせることを主題とした作品。',
    targetLen: 35,
    minDialog: 55,
    weights: { vocab: 1.3, description: 1.2, dialogue: 1.7, sentiment: 1.3, ending: 1.5, viewpoint: 1.1, tempo: 1.6, redundancy: 1.2, connector: 1.2, keyword: 1.2 },
    keywords: '笑|爆笑|ギャグ|ツッコミ|ボケ|ドタバタ|勘違い|ハプニング|おかしい|面白|バカ|アホ|ユーモア|' +
              '吹き出|腹筋|崩壊|草|www|（笑）|苦笑|失笑|大爆笑|ニヤニヤ|ゲラ|抱腹絶倒|滑稽|茶番|コント|漫才|オチ|フリ|伏線|台無し|' +
              'カオス|混沌|シュール|ナンセンス|不条理|意味不明|理解不能|奇行|変人|奇人|変態|紳士|ポンコツ|ドジ|うっかり|天然|残念|無能|天才|紙一重|脳筋|筋肉|マッスル|ゴリラ|厨二|黒歴史|痛い|寒い|滑る|' +
              '叫び|絶叫|悲鳴|怒号|罵倒|説教|正座|土下座|平謝り|逆ギレ|無視|スルー|真顔|ドヤ顔|変顔|顔芸|白目|涙目|鼻血|滝汗|冷や汗|ガクブル|' +
              '殴|蹴|叩|チョップ|ハリセン|スリッパ|爆発|自爆|暴走|乱入|破壊|粉砕|玉砕|激突|吹っ飛|空|星|' +
              'メタ|パロディ|オマージュ|天丼|お約束|テンプレ|フラグ|回収|ご都合|作者|神|主人公|補正|チート|インフレ|' +
              '貧乏|金欠|借金|社畜|ニート|引きこもり|リア充|爆発しろ|ボッチ|陰キャ|陽キャ|全裸|パンツ|モザイク|ピー音|規制|放送事故|異次元|宇宙'
},
           sf_vr: {
    name: 'VRゲーム',
    desc: 'VR技術を利用したゲームが主体となる作品。',
    targetLen: 50,
    minDialog: 40,
    weights: { vocab: 1.4, description: 1.4, dialogue: 1.4, sentiment: 1.2, ending: 1.3, viewpoint: 1.2, tempo: 1.4, redundancy: 1.3, connector: 1.2, keyword: 1.5 },
    keywords: 'VR|AR|MR|ゲーム|仮想|現実|ログイン|ログアウト|スキル|レベル|クエスト|ダンジョン|プレイヤー|NPC|AI|人工知能|ステータス|' +
              'フルダイブ|ヘッドギア|カプセル|脳波|接続|リンク|ダイブ|サーバー|ラグ|回線|バグ|グリッチ|チート|不正|BAN|垢バン|運営|GM|開発|アプデ|メンテ|パッチ|ナーフ|強化|調整|' +
              'アバター|キャラメイク|キャラクリ|種族|人間|エルフ|獣人|職業|ジョブ|クラス|生産|鍛冶|錬金|料理|裁縫|釣り|採集|採掘|農業|テイム|従魔|ペット|' +
              'HP|MP|STR|VIT|INT|AGI|DEX|LUK|攻撃力|防御力|敏捷|幸運|熟練度|経験値|EXP|SP|カンスト|極振り|ビルド|アーツ|魔法|テクニック|パッシブ|アクティブ|クールタイム|リキャスト|バフ|デバフ|' +
              'メニュー|ウィンドウ|インベントリ|ストレージ|アイテム|ボックス|装備|武器|防具|アクセサリー|ポーション|課金|ガチャ|ショップ|通貨|ゴールド|G|円|リアルマネー|RMT|' +
              'レア|コモン|アンコモン|レジェンド|ユニーク|エピック|神話|アーティファクト|隠し|裏|限定|称号|実績|トロフィー|ファースト|クリア|独占|発見|' +
              'パーティ|ソロ|野良|固定|ギルド|クラン|チーム|リーダー|メンバー|フレンド|チャット|ボイチャ|VC|メッセージ|メール|申請|ブロック|' +
              '攻略|検証|ガチ勢|エンジョイ勢|廃人|初心者|新規|古参|地雷|姫|囲い|ランカー|トップ|有名|プロ|' +
              'フィールド|エリア|マップ|街|拠点|セーフティ|リスポーン|蘇生|デスペナ|死に戻り|' +
              'ボス|レイド|モンスター|モブ|ドロップ|報酬|宝箱|イベント|ワールド|シナリオ|ストーリー|PvP|PK|Pk|キル|決闘|闘技場|大会|GvG|戦争|攻城戦|' +
              '掲示板|スレ|レス|安価|Wiki|サイト|動画|配信|実況|生放送|ストリーマー|視聴者|リスナー|同接|コメント|スパチャ|炎上|祭り|晒し|特定|ネカマ|ロールプレイ'
},
           sf_space: {
    name: '宇宙',
    desc: '宇宙を舞台とした作品。',
    targetLen: 60,
    minDialog: 30,
    weights: { vocab: 1.6, description: 1.6, dialogue: 1.2, sentiment: 1.1, ending: 1.2, viewpoint: 1.3, tempo: 1.3, redundancy: 1.4, connector: 1.3, keyword: 1.4 },
    keywords: '宇宙|星|惑星|銀河|艦|船|宇宙船|宇宙人|エイリアン|コロニー|ステーション|軌道|航行|' +
              '戦艦|巡洋艦|駆逐艦|空母|母艦|輸送艦|戦闘機|機動兵器|ロボット|パワードスーツ|ドック|ポート|' +
              '艦長|提督|司令|クルー|乗員|パイロット|操舵|機関|通信|オペレーター|ドロイド|アンドロイド|サイボーグ|AI|人工知能|' +
              'ワープ|跳躍|亜空間|ゲート|超光速|光速|亜光速|エンジン|スラスター|バーニア|推進|燃料|エネルギー|出力|炉|リアクター|ジェネレーター|重力|反重力|人工重力|無重力|G|慣性|真空|酸素|気密|宇宙服|ヘルメット|バイザー|エアロック|ハッチ|ブリッジ|艦橋|' +
              'レーザー|ビーム|ブラスター|レールガン|粒子砲|主砲|副砲|機銃|ミサイル|魚雷|弾幕|斉射|砲火|シールド|バリア|フィールド|展開|装甲|船体|隔壁|迎撃|回避|ロックオン|レーダー|センサー|反応|照準|捕捉|撃墜|撃沈|轟沈|大破|爆散|デブリ|残骸|' +
              '帝国|連邦|共和国|連合|同盟|軍|艦隊|戦隊|分艦隊|編隊|僚機|陣形|包囲|突撃|離脱|エース|英雄|反乱|レジスタンス|テロ|海賊|傭兵|交易|' +
              '太陽|月|地球|火星|木星|土星|衛星|彗星|流星|隕石|アステロイド|小惑星|ブラックホール|星雲|地平線|未開|開拓|テラフォーミング|環境|汚染|資源|採掘|第一次|第二次|大戦'
},
          sf_science: {
    name: '空想科学',
    desc: '実在、非実在を問わず、何らかの技術・理論の要素を含む作品。',
    targetLen: 65,
    minDialog: 25,
    weights: { vocab: 1.7, description: 1.6, dialogue: 1.1, sentiment: 1.0, ending: 1.2, viewpoint: 1.4, tempo: 1.2, redundancy: 1.5, connector: 1.5, keyword: 1.4 },
    keywords: '科学|技術|理論|実験|研究|開発|博士|教授|未来|近未来|機械|ロボット|アンドロイド|AI|人工知能|' +
              'データ|解析|分析|数値|計算|プログラム|コード|アルゴリズム|システム|ネットワーク|サーバー|ハッキング|アクセス|認証|セキュリティ|暗号|電子|電脳|サイバー|デジタル|仮想|拡張|インターフェース|デバイス|端末|' +
              '物理|法則|エネルギー|原子|分子|粒子|量子|次元|重力|磁場|相対性|光速|時空|時間|タイムマシン|タイムトラベル|パラレルワールド|世界線|分岐|ループ|パラドックス|矛盾|因果|' +
              '生物|生命|遺伝子|DNA|ゲノム|クローン|培養|進化|退化|突然変異|ウイルス|細菌|感染|パンデミック|ワクチン|ナノマシン|ナノテク|サイボーグ|義体|生体|脳|意識|記憶|人格|転送|' +
              '文明|社会|都市|管理|監視|統治|政府|企業|ドローン|自動|自律|暴走|制御|エラー|故障|修理|廃棄|リサイクル|シンギュラリティ|技術的特異点|ディストピア|ユートピア|終末|崩壊|' +
              '仮説|証明|論理|矛盾|未知|既知|可能性|確率|観測|事象|存在|認識|倫理|哲学|神|創造|人間|人類|新人類'
},
           sf_panic: {
    name: 'パニック',
    desc: '天災・汚染・大事故・侵略等の危機的状況下を舞台とした作品。',
    targetLen: 45,
    minDialog: 35,
    weights: { vocab: 1.4, description: 1.6, dialogue: 1.4, sentiment: 1.4, ending: 1.4, viewpoint: 1.3, tempo: 1.5, redundancy: 1.2, connector: 1.3, keyword: 1.3 },
    keywords: '災害|危機|パニック|崩壊|破壊|逃走|避難|生存|死|恐怖|混乱|絶望|希望|侵略|汚染|' +
              'パンデミック|アウトブレイク|ウイルス|感染|発症|潜伏|隔離|封鎖|ロックダウン|ワクチン|特効薬|抗体|免疫|マスク|防護服|' +
              'ゾンビ|感染者|リビングデッド|噛まれる|転化|増殖|暴徒|怪獣|巨大生物|エイリアン|UFO|侵略者|隕石|衝突|噴火|地震|津波|洪水|異常気象|氷河期|' +
              '停電|断水|ガス|インフラ|ブラックアウト|通信|遮断|圏外|ネット|SNS|デマ|噂|報道|ニュース|緊急|速報|警報|サイレン|放送|Jアラート|' +
              '暴動|略奪|強盗|放火|殺人|治安|悪化|無法|ヒャッハー|警察|自衛隊|軍|政府|放棄|機能不全|戒厳令|' +
              '脱出|移動|車|渋滞|事故|炎上|爆発|火災|黒煙|瓦礫|廃墟|ゴーストタウン|都市|ビル|地下鉄|トンネル|' +
              'サバイバル|籠城|バリケード|備蓄|食料|水|缶詰|保存食|武器|バール|ナイフ|銃|弾薬|ライト|ラジオ|バッテリー|発電機|' +
              'スーパー|コンビニ|ホームセンター|薬局|病院|学校|体育館|避難所|キャンプ|シェルター|安全地帯|セーフハウス|' +
              '家族|恋人|友人|他人|集団|グループ|リーダー|独裁|仲間|協力|内輪揉め|疑惑|疑心暗鬼|裏切り|見殺し|犠牲|囮|人柱|' +
              '叫び|悲鳴|泣き声|怒号|狂気|正気|錯乱|ヒステリー|疲労|空腹|飢餓|渇き|怪我|出血|死体|遺体|山積み|悪臭|腐臭|' +
              'タイムリミット|カウントダウン|救助|救援|ヘリ|船|ノアの方舟|選別|優先|見捨てる|生き残る|生存者'
},
           other_fairy: {
    name: '童話',
    desc: '幼年、児童に向けた内容の読み物。',
    targetLen: 35,
    minDialog: 50,
    weights: { vocab: 1.2, description: 1.4, dialogue: 1.6, sentiment: 1.3, ending: 1.3, viewpoint: 1.1, tempo: 1.3, redundancy: 1.1, connector: 1.1, keyword: 1.2 },
    keywords: '優しい|楽しい|仲間|冒険|魔法|王子|姫|動物|森|お城|ハッピーエンド|教訓|' +
              'むかしむかし|あるところに|おじいさん|おばあさん|男の子|女の子|子供|赤ちゃん|お父さん|お母さん|王様|女王様|神様|天使|' +
              'うさぎ|くま|ねこ|いぬ|きつね|たぬき|おおかみ|ライオン|ねずみ|とり|小鳥|魚|虫|蝶々|' +
              '妖精|小人|巨人|魔女|魔法使い|おばけ|怪物|ドラゴン|竜|人魚|鬼|' +
              'わくわく|ドキドキ|キラキラ|ふわふわ|ニコニコ|ピカピカ|どんどん|てくてく|ぴょんぴょん|ぐすん|しくしく|えーん|' +
              '友達|仲良し|喧嘩|仲直り|約束|嘘|本当|正直|勇気|知恵|力持ち|意地悪|親切|恩返し|' +
              'お菓子|ケーキ|キャンディ|パン|リンゴ|ごちそう|宝物|金貨|地図|手紙|' +
              'お家|小屋|洞窟|塔|学校|公園|空|星|お月様|太陽|雲|虹|花|木|川|海|山|' +
              '夢|願い|お祈り|誕生日|クリスマス|プレゼント|歌|ダンス|お祭り|' +
              '迷子|お使い|旅|出発|帰り道|ただいま|おかえり|ごめんなさい|ありがとう|' +
              'めでたしめでたし|幸せ|笑顔|平和|不思議|秘密|物語|お話'
},
            other_poem: {
    name: '詩',
    desc: '言葉に美と響きを乗せて想いを表現している作品。',
    targetLen: 25,
    minDialog: 10,
    weights: { vocab: 1.8, description: 1.6, dialogue: 0.8, sentiment: 1.6, ending: 1.5, viewpoint: 1.2, tempo: 1.4, redundancy: 1.4, connector: 1.0, keyword: 1.0 },
    keywords: '心|魂|風|光|影|夢|空|海|花|月|星|愛|美|響き|想い|' +
              '雨|雪|雲|霧|霞|雷|虹|太陽|陽射し|木漏れ日|夕暮れ|黄昏|夜明け|朝|昼|夕|夜|深夜|' +
              '春|夏|秋|冬|季節|桜|向日葵|紅葉|枯葉|樹木|森|林|川|水|雫|波|潮騒|' +
              '色|白|黒|青|赤|碧|蒼|朱|金|銀|透明|色彩|匂い|香り|音|声|歌|旋律|リズム|メロディ|' +
              '永遠|刹那|瞬間|時間|記憶|過去|未来|現在|運命|奇跡|幻|幻想|真実|嘘|秘密|' +
              '悲しみ|喜び|怒り|嘆き|祈り|願い|希望|絶望|孤独|静寂|沈黙|安らぎ|癒し|痛み|傷|涙|笑顔|' +
              '言葉|言の葉|詩|歌|手紙|物語|世界|宇宙|彼方|翼|飛翔|自由|束縛|生|死|命|鼓動'
},
            other_essay: {
    name: 'エッセイ',
    desc: '個人的観点により思想や物事を論じている作品。',
    targetLen: 60,
    minDialog: 15,
    weights: { vocab: 1.6, description: 1.4, dialogue: 1.0, sentiment: 1.2, ending: 1.3, viewpoint: 1.3, tempo: 1.2, redundancy: 1.5, connector: 1.5, keyword: 1.0 },
    keywords: '思う|考える|感じる|私|経験|日常|生活|社会|人生|視点|意見|観察|' +
              '考察|分析|結論|理由|原因|結果|疑問|仮説|検証|納得|理解|把握|認識|意識|無意識|' +
              '主観|客観|個人的|一般的|常識|偏見|先入観|価値観|正義|悪|是非|賛否|批判|肯定|否定|共感|反感|' +
              '執筆|創作|小説|物語|文章|表現|読者|作者|ユーザー|PV|ポイント|評価|感想|レビュー|ランキング|書籍化|コンテスト|スランプ|プロット|ネタ|更新|' +
              '実話|ノンフィクション|体験談|失敗談|成功談|思い出|記憶|過去|現在|未来|きっかけ|動機|教訓|' +
              'ニュース|時事|話題|流行|トレンド|問題|解決|提案|主張|言いたい|伝えたい|' +
              '趣味|仕事|勉強|学校|会社|政治|経済|文化|宗教|哲学|心理|人間関係|ストレス|悩み|相談|' +
              'ブログ|日記|雑記|備忘録|メモ|独り言|語り|紹介|解説|方法|ノウハウ|コツ|アドバイス'
},
            other_replay: {
    name: 'リプレイ',
    desc: 'TRPGのプレイ結果を文章にて記録したもの。',
    targetLen: 40,
    minDialog: 60,
    weights: { vocab: 1.2, description: 1.3, dialogue: 1.7, sentiment: 1.2, ending: 1.2, viewpoint: 1.1, tempo: 1.4, redundancy: 1.1, connector: 1.2, keyword: 1.3 },
    keywords: 'ダイス|判定|成功|失敗|スキル|キャラクター|PC|GM|セッション|シナリオ|ロール|' +
              'サイコロ|1D100|2D6|出目|クリティカル|ファンブル|決定的成功|致命的失敗|振り直し|技能|チェック|抵抗|対抗|難易度|ボーナス|ペナルティ|期待値|' +
              'KP|キーパー|DM|PL|プレイヤー|ハンドアウト|HO|秘匿|探索者|冒険者|NPC|黒幕|ラスボス|立ち絵|' +
              'SAN|正気度|発狂|狂気|不定|HP|MP|STR|DEX|INT|POW|APP|SIZ|EDU|ステータス|能力値|キャラシ|CS|職業|特徴|' +
              '目星|聞き耳|図書館|心理学|説得|言いくるめ|オカルト|回避|キック|こぶし|マーシャルアーツ|応急手当|医学|' +
              '戦闘|イニシアティブ|ラウンド|ターン|攻撃|ダメージ|装甲|武器|アイテム|呪文|魔法|アーティファクト|魔導書|神話生物|' +
              '卓|オンセ|テキセ|ボイセ|ログ|動画|仮想卓|茶番|休憩|相談|提案|メタ|描写|宣言|情報|共有|開示|' +
              '導入|探索|クライマックス|エンディング|ロスト|生還|全滅|トゥルー|バッド|ハッピー|分岐|' +
              '笑|爆笑|困惑|絶望|悲鳴|合掌|祈り|リアル|中の人'
},
       other_misc: {
    name: 'その他',
    desc: '上記ジャンルに該当しない作品。',
    targetLen: 50,
    minDialog: 35,
    weights: { vocab: 1.3, description: 1.3, dialogue: 1.3, sentiment: 1.2, ending: 1.2, viewpoint: 1.2, tempo: 1.2, redundancy: 1.2, connector: 1.2, keyword: 1.0 },
    keywords: '物語|小説|短編|掌編|ショートショート|オムニバス|連作|日常|生活|雑多|未分類|ノンジャンル|' +
              '趣味|料理|グルメ|食事|酒|レシピ|旅行|散歩|写真|音楽|楽器|バンド|美術|芸術|絵画|映画|本|読書|' +
              'ペット|猫|犬|動物|植物|花|自然|園芸|農業|' +
              '実験|前衛|シュール|不思議|謎|自由|カオス|夢|幻想|' +
              '仕事|ビジネス|学校|学生|大人|子供|現代|日本|世界|海外|文化|風習|' +
              '友情|家族|青春|人生|' +
              '創作|フィクション|クロスオーバー|コラボ|IF|パラレル'
}
        };

        const groupedGenres = {
            '恋愛': [
                { id: 'love_isekai', name: '恋愛（異世界）' },
                { id: 'love_real', name: '恋愛（現実世界）' }
            ],
            'ファンタジー': [
                { id: 'fantasy_high', name: 'ハイファンタジー' },
                { id: 'fantasy_low', name: 'ローファンタジー' }
            ],
            '文芸': [
                { id: 'literary_pure', name: '純文学' },
                { id: 'literary_human', name: 'ヒューマンドラマ' },
                { id: 'literary_history', name: '歴史' },
                { id: 'literary_mystery', name: '推理' },
                { id: 'literary_horror', name: 'ホラー' },
                { id: 'literary_action', name: 'アクション' },
                { id: 'literary_comedy', name: 'コメディー' }
            ],
            'SF': [
                { id: 'sf_vr', name: 'VRゲーム' },
                { id: 'sf_space', name: '宇宙' },
                { id: 'sf_science', name: '空想科学' },
                { id: 'sf_panic', name: 'パニック' }
            ],
            'その他': [
                { id: 'other_fairy', name: '童話' },
                { id: 'other_poem', name: '詩' },
                { id: 'other_essay', name: 'エッセイ' },
                { id: 'other_replay', name: 'リプレイ' },
                { id: 'other_misc', name: 'その他' }
            ]
        };

        const currentScoringProfile = computed(() => scoringProfiles[selectedGenre.value]);

        const rankColorClass = computed(() => {
            if (!stats.value) return '';
            const r = stats.value.rank;
            if (r === 'SS' || r === 'S') return 'bg-gradient-to-b from-yellow-400 to-orange-500';
            if (r === 'A') return 'bg-gradient-to-b from-green-400 to-emerald-600';
            if (r === 'B') return 'bg-gradient-to-b from-blue-400 to-blue-600';
            if (r === 'C') return 'bg-gradient-to-b from-gray-400 to-gray-600';
            return 'bg-gradient-to-b from-red-400 to-red-600';
        });

        const rankGradient = computed(() => {
            if (!stats.value) return '';
            const r = stats.value.rank;
            if (r === 'SS' || r === 'S') return 'from-yellow-400 to-orange-500';
            if (r === 'A') return 'from-green-400 to-emerald-600';
            if (r === 'B') return 'from-blue-400 to-blue-600';
            if (r === 'C') return 'from-gray-400 to-gray-600';
            return 'from-red-400 to-red-600';
        });

        const showToast = (msg, type = 'alert-info', icon = 'ph-fill ph-info') => {
            toastMessage.value = msg;
            toastType.value = type;
            toastIcon.value = icon;
            setTimeout(() => { toastMessage.value = ''; }, 3000);
        };

        const shareResult = () => {
            if (!stats.value) return;
            const text = `Narou Analyzer Ultra3.2\nジャンル: ${currentScoringProfile.value.name}\nランク: ${stats.value.rank} (${stats.value.totalScore.toFixed(1)}点)\n#なろうアナライザー`;
            if (navigator.share) {
                navigator.share({ title: 'なろうアナライザー結果', text });
            } else {
                navigator.clipboard.writeText(text);
                showToast('結果をクリップボードにコピーしました！', 'alert-success', 'ph-fill ph-check-circle');
            }
        };

        // カード画像を生成する内部関数
        const generateCardImage = async () => {
            if (!stats.value) return null;
            
            // カード用データを設定
            document.getElementById('cardGenre').textContent = currentScoringProfile.value.name;
            document.getElementById('cardRank').textContent = stats.value.rank;
            document.getElementById('cardScore').innerHTML = `${stats.value.totalScore.toFixed(1)}<span style="font-size: 18px;">/100</span>`;
            
            // AIコメントの表示/非表示
            const aiCommentSection = document.getElementById('cardAICommentSection');
            if (isAIMode.value && aiComment.value && !isAIProcessing.value) {
                aiCommentSection.style.display = 'block';
                document.getElementById('cardAIComment').textContent = `「${aiComment.value}」`;
            } else {
                aiCommentSection.style.display = 'none';
            }
            
            // 既存のチャートがあれば破棄
            const existingChart = Chart.getChart('cardRadarChart');
            if (existingChart) {
                existingChart.destroy();
            }
            
            // レーダーチャートを描画
            const cardCanvas = document.getElementById('cardRadarChart');
            const cardCtx = cardCanvas.getContext('2d');
            
            new Chart(cardCtx, {
                type: 'radar',
                data: {
                    labels: stats.value.radarData.map(d => d.label),
                    datasets: [{
                        label: 'スコア',
                        data: stats.value.radarData.map(d => d.score),
                        backgroundColor: 'rgba(102, 126, 234, 0.25)',
                        borderColor: '#667eea',
                        borderWidth: 3,
                        pointBackgroundColor: '#667eea',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 6
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            min: 0,
                            max: 100,
                            ticks: {
                                stepSize: 25,
                                font: { size: 14 },
                                color: '#64748b'
                            },
                            pointLabels: {
                                font: { size: 15, weight: 'bold' },
                                color: '#334155'
                            },
                            grid: { color: '#cbd5e1' }
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });
            
            // 少し待ってからキャプチャ
            await new Promise(resolve => setTimeout(resolve, 500));
            
            try {
                const canvas = await html2canvas(document.getElementById('shareCard'), {
                    backgroundColor: null,
                    scale: 2,
                    logging: false
                });
                
                return canvas;
            } catch (error) {
                console.error('Card generation error:', error);
                return null;
            }
        };

        // テキストをコピー
        const copyResultText = () => {
            if (!stats.value) return;
            const text = `私の小説戦闘力は${stats.value.rank}ランク！（${stats.value.totalScore.toFixed(1)}点）\nジャンル: ${currentScoringProfile.value.name}\n\n#なろうアナライザー\nhttps://limehato74.github.io/NarouAnalyzer/`;
            navigator.clipboard.writeText(text);
            showToast('テキストをクリップボードにコピーしました！', 'alert-success', 'ph-fill ph-check-circle');
        };

        // 画像をダウンロード
        const downloadCard = async () => {
            showToast('画像を生成中...', 'alert-info', 'ph-fill ph-image');
            
            const canvas = await generateCardImage();
            if (!canvas) {
                showToast('画像生成に失敗しました', 'alert-error', 'ph-fill ph-x-circle');
                return;
            }
            
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `narou-analyzer-${stats.value.rank}-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
                
                showToast('カード画像をダウンロードしました！', 'alert-success', 'ph-fill ph-check-circle');
            });
        };

        // LINEで共有
        const shareToLine = () => {
            if (!stats.value) return;
            const text = `私の小説戦闘力は${stats.value.rank}ランク！（${stats.value.totalScore.toFixed(1)}点）\nジャンル: ${currentScoringProfile.value.name}\n\n#なろうアナライザー\nhttps://limehato74.github.io/NarouAnalyzer/`;
            const url = `https://line.me/R/msg/text/?${encodeURIComponent(text)}`;
            window.open(url, '_blank');
        };

        // Xに直接投稿（テキストのみ）
        const shareToXDirect = () => {
            if (!stats.value) return;
            const text = `私の小説戦闘力は${stats.value.rank}ランク！（${stats.value.totalScore.toFixed(1)}点）\nジャンル: ${currentScoringProfile.value.name}\n\n#なろうアナライザー\nhttps://limehato74.github.io/NarouAnalyzer/`;
            const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
            window.open(url, '_blank');
        };

        watch(isDarkMode, (val) => {
            document.documentElement.setAttribute('data-theme', val ? 'night' : 'winter');
            if (stats.value) {
                nextTick(() => renderCharts(stats.value));
            }
        });

        // AIモードの切り替えを監視
        watch(isAIMode, (newVal, oldVal) => {
            // チェックボックスがオンになろうとしている && まだ規約に同意していない
            if (newVal === true && !hasAgreedToAITerms.value) {
                // すぐにチェックを外す
                isAIMode.value = false;
                // モーダルを表示
                showAITermsModal.value = true;
            }
        });

        // 規約に同意
        const acceptAITerms = () => {
            hasAgreedToAITerms.value = true;
            showAITermsModal.value = false;
            isAIMode.value = true;
            
            // localStorageに保存（次回以降は表示しない）
            try {
                localStorage.setItem('aiTermsAgreed', 'true');
            } catch (e) {
                console.warn('localStorage not available');
            }
            
            showToast('AIモードを有効化しました', 'alert-success', 'ph-fill ph-check-circle');
        };

        // 規約に同意しない
        const declineAITerms = () => {
            showAITermsModal.value = false;
            isAIMode.value = false;
            showToast('AIモードは無効のままです', 'alert-info', 'ph-fill ph-info');
        };

        const analyzeText = () => {
            const text = inputText.value.trim();
            if (text.length < 100) {
                showToast('100文字以上のテキストを入力してください', 'alert-warning', 'ph-fill ph-warning');
                return;
            }

            isProcessing.value = true;
            setTimeout(() => {
                const result = performAnalysis(text);
                stats.value = result;
                generateAdvice(result.contentMetrics, currentScoringProfile.value);
                nextTick(() => {
                    renderCharts(result);
                    document.getElementById('results-area')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    
                    // AIモードがオンの場合はAI分析も実行
                    if (isAIMode.value) {
                        analyzeWithAI();
                    }
                });
                isProcessing.value = false;
            }, 300);
        };

        const onGenreChange = () => {
            // すでに分析結果が存在し、テキストが100文字以上の場合のみ自動再採点
            if (stats.value && inputText.value.trim().length >= 100) {
                showToast(`${currentScoringProfile.value.name}で再採点中...`, 'alert-info', 'ph-fill ph-arrows-clockwise');
                analyzeText();
            }
        };

const analyzeWithAI = async () => {
            if (!stats.value) {
                showToast('先に基本分析を実行してください', 'alert-warning', 'ph-fill ph-warning');
                return;
            }

            isAIProcessing.value = true;
            aiComment.value = 'AIが本文を精読して採点中...（20〜30秒かかります）';

            try {
                const profile = currentScoringProfile.value;
                
                // AI採点用の詳細プロンプト（採点部分）
                const scoringPrompt = `あなたはプロの小説編集者です。以下の${profile.name}の本文を精読し、各項目を100点満点で採点してください。

【本文】
${inputText.value.substring(0, 2000)}

【採点項目】※${profile.name}の基準で評価
1. 描写力（五感・心理描写の豊かさ）: 0-100点
2. 会話の自然さ（${profile.minDialog}%前後が理想）: 0-100点
3. 感情表現（ポジティブ/ネガティブのバランス）: 0-100点
4. 文末のバリエーション: 0-100点
5. 視点の一貫性: 0-100点
6. 文章のリズム（長短の変化）: 0-100点
7. 冗長性の少なさ: 0-100点
8. 接続詞の適切さ: 0-100点
9. ジャンル適合度（${profile.name}らしさ）: 0-100点
10. 語彙の豊かさ: 0-100点

【出力形式】必ず以下のJSON形式で出力してください。
{
  "scores": {
    "description": 85,
    "dialogue": 78,
    "sentiment": 82,
    "ending": 75,
    "viewpoint": 90,
    "tempo": 80,
    "redundancy": 88,
    "connector": 76,
    "keyword": 84,
    "vocabulary": 79
  },
  "totalScore": 81.7,
  "rank": "B+"
}

※ランクは S(95-100), A+(90-94), A(85-89), B+(80-84), B(75-79), C+(70-74), C(65-69), D(0-64)`;

                // 感想生成用のプロンプト（別途）
                const impressionPrompt = `あなたは${profile.name}が好きな一般読者です。以下の小説を読んで、純粋な読後感想を書いてください。

【本文】
${inputText.value.substring(0, 2000)}

【感想の書き方】
- 文章の技術や構成には一切触れないでください
- ストーリー、キャラクター、シーン、雰囲気、感情など「内容」についてのみ語ってください
- 「〜が印象的だった」「〜のシーンで胸が熱くなった」「〜の心情が伝わってきた」のように具体的に
- 200文字程度で、読者として素直に感じたことを書いてください

悪い例：「文章のリズムが良く、描写が丁寧で読みやすかったです」
良い例：「主人公が過去と向き合うシーンが切なく、涙が出そうになりました。仲間との絆の描写も温かくて、続きが気になります」`;

                // まず採点を実行
                const scoringResponse = await fetch('https://falling-brook-e720.boleft704.workers.dev/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: scoringPrompt })
                });

                const scoringData = await scoringResponse.json();

                if (!scoringResponse.ok) {
                    throw new Error(scoringData.error || `通信エラー: ${scoringResponse.status}`);
                }

                // 採点結果をパース
                let aiResult;
                try {
                    const jsonMatch = scoringData.result.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        aiResult = JSON.parse(jsonMatch[0]);
                        
                        // AIの採点結果でstatsを更新
                        if (aiResult.scores && aiResult.totalScore) {
                            stats.value.totalScore = aiResult.totalScore;
                            stats.value.rank = aiResult.rank || getRank(aiResult.totalScore);
                            
                            // レーダーチャートのデータを更新
                            stats.value.radarData = [
                                { label: '描写力', score: aiResult.scores.description || 50 },
                                { label: '会話', score: aiResult.scores.dialogue || 50 },
                                { label: '感情表現', score: aiResult.scores.sentiment || 50 },
                                { label: '文末', score: aiResult.scores.ending || 50 },
                                { label: '視点', score: aiResult.scores.viewpoint || 50 },
                                { label: 'リズム', score: aiResult.scores.tempo || 50 },
                                { label: '冗長性', score: aiResult.scores.redundancy || 50 },
                                { label: '接続詞', score: aiResult.scores.connector || 50 },
                                { label: 'ジャンル', score: aiResult.scores.keyword || 50 },
                                { label: '語彙', score: aiResult.scores.vocabulary || 50 }
                            ];
                            
                            // チャートを再描画
                            nextTick(() => {
                                renderCharts(stats.value);
                            });
                        }
                    }
                } catch (parseError) {
                    console.warn('JSON Parse Error:', parseError);
                }

                // 次に感想を生成
                aiComment.value = 'AIが読後感想を書いています...';
                
                const impressionResponse = await fetch('https://falling-brook-e720.boleft704.workers.dev/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: impressionPrompt })
                });

                const impressionData = await impressionResponse.json();

                if (!impressionResponse.ok) {
                    throw new Error(impressionData.error || `通信エラー: ${impressionResponse.status}`);
                }

                // 感想を表示
                aiComment.value = impressionData.result;
                showToast('AIによる採点と感想が完了しました！', 'alert-success', 'ph-fill ph-check-circle');

            } catch (error) {
                console.error('AI Processing Error:', error);
                showToast(error.message, 'alert-error', 'ph-fill ph-x-circle');
                aiComment.value = '分析に失敗しました。時間をおいて再度お試しください。';
            } finally {
                isAIProcessing.value = false;
            }
        };
        
        // ランク判定関数
        const getRank = (score) => {
            if (score >= 95) return 'S';
            if (score >= 90) return 'A+';
            if (score >= 85) return 'A';
            if (score >= 80) return 'B+';
            if (score >= 75) return 'B';
            if (score >= 70) return 'C+';
            if (score >= 65) return 'C';
            return 'D';
        };
        const performAnalysis = (text) => {
            const profile = currentScoringProfile.value;
            
            const sentences = text.split(/[。！？\n]/).filter(s => s.trim().length > 0);
            const totalChars = text.replace(/\s/g, '').length;
            const avgLen = totalChars / sentences.length;
            
            const sentenceLengths = sentences.map(s => s.replace(/\s/g, '').length);
            const variance = sentenceLengths.reduce((sum, len) => sum + Math.pow(len - avgLen, 2), 0) / sentences.length;
            const stdDev = Math.sqrt(variance);
            const tempoVariance = stdDev / avgLen;
            
            const dialogLines = text.match(/「[^」]*」|『[^』]*』|"[^"]*"|'[^']*'/g) || [];
            const dialogChars = dialogLines.join('').length;
            const dialogRatio = (dialogChars / totalChars) * 100;
            
          const endingPatterns = {
    // -------------------------
    // 【基本・断定】 (Basic Assertion)
    // -------------------------
    '〜る（辞書形）': /[るうくぐすつぬむぶぷ][。！？」』]/g,
    '〜だ（断定・常体）': /だ[。！？」』]/g,
    '〜である（形式ばった断定）': /である[。！？」』]/g,
    '〜の（断定省略・女性/子供）': /(?:る|た|ない|いる|ある)の[。！？」』]/g,

    // -------------------------
    // 【丁寧・敬語】 (Polite)
    // -------------------------
    '〜ます（丁寧・現在）': /ます[。！？」』]/g,
    '〜です（丁寧・断定）': /です[。！？」』]/g,
    '〜でございます（丁寧・丁重）': /でございます[。！？」』]/g,
    '〜ございます（丁寧・存在）': /ございます[。！？」』]/g,
    '〜致します（謙譲）': /致します[。！？」』]/g,
    '〜参ります（謙譲）': /参ります[。！？」』]/g,

    // -------------------------
    // 【過去・完了】 (Past / Perfect)
    // -------------------------
    '〜た/だ（過去・常体）': /[ただ][。！？」』]/g,
    '〜ました（過去・丁寧）': /ました[。！？」』]/g,
    '〜でした（過去・丁寧断定）': /でした[。！？」』]/g,
    '〜てしまった/ちゃった（完了・遺憾）': /(?:てしまった|ちゃった|じゃった)[。！？」』]/g,
    '〜ていた（過去進行）': /ていた[。！？」』]/g,
    '〜てあった（状態保持）': /てあった[。！？」』]/g,

    // -------------------------
    // 【否定】 (Negative)
    // -------------------------
    '〜ない（否定・常体）': /ない[。！？」』]/g,
    '〜ん（否定・口語/方言）': /ん[。！？」』]/g, // "わからん"など
    '〜ません（否定・丁寧）': /ません[。！？」』]/g,
    '〜ないです（否定・丁寧口語）': /ないです[。！？」』]/g,
    '〜ず（打ち消し・古風/書き言葉）': /ず[。！？」』]/g,

    // -------------------------
    // 【推量・様態・伝聞】 (Conjecture / Hearsay)
    // -------------------------
    '〜だろう（推量・常体）': /だろう[。！？」』]/g,
    '〜でしょう（推量・丁寧）': /でしょう[。！？」』]/g,
    '〜らしい（伝聞・推定）': /らしい[。！？」』]/g,
    '〜そうだ（様態・伝聞）': /そうだ[。！？」』]/g,
    '〜ようだ（比況・推定）': /ようだ[。！？」』]/g,
    '〜みたいだ（比況・口語）': /みたい[だです]?[。！？」』]/g,
    '〜かもしれない（可能性）': /かもしれない[。！？」』]/g,
    '〜はずだ（確信）': /はず[だです]?[。！？」』]/g,
    '〜に違いない（強い確信）': /に違いない[。！？」』]/g,

    // -------------------------
    // 【意志・願望・勧誘】 (Volitional / Desire)
    // -------------------------
    '〜たい（願望）': /たい[。！？」』]/g,
    '〜たいです（願望・丁寧）': /たいです[。！？」』]/g,
    '〜よう/おう（意志・勧誘）': /(?:よう|おう)[。！？」』]/g,
    '〜ましょう（勧誘・丁寧）': /ましょう[。！？」』]/g,
    '〜ほしがる（第三者の願望）': /ほしがる[。！？」』]/g,

    // -------------------------
    // 【義務・当然・不可避】 (Obligation / Necessity)
    // -------------------------
    '〜べきだ（義務）': /べき(?:だ|です|である)[。！？」』]/g,
    '〜なければならない（義務）': /(?:なければ|なきゃ)(?:ならない|いけない|なんない)[。！？」』]/g,
    '〜ざるを得ない（不可避）': /ざるを得ない[。！？」』]/g,
    '〜ことだ（忠告）': /こと[だです][。！？」』]/g,

    // -------------------------
    // 【強調・説明・形式名詞】 (Emphasis / Explanation)
    // -------------------------
    '〜のだ/んだ（強調・説明）': /[のん][だです][。！？」』]/g,
    '〜わけだ（納得・結論）': /わけ[だです][。！？」』]/g,
    '〜ものだ（詠嘆・一般論）': /もの[だです][。！？」』]/g,
    '〜こと（書き言葉・命令）': /こと[。！？」』]/g, // "～すること。"

    // -------------------------
    // 【疑問・反語】 (Question)
    // -------------------------
    '〜か（疑問）': /か[。！？」』]/g,
    '〜かい/だい（疑問・親愛）': /[かだ]い[。！？」』]/g,
    '〜の（疑問・イントネーション）': /の[？][。！？」』]?/g, // 文末が「の？」の場合
    '〜かしら/かな（疑問・自問）': /(?:かしら|かな)[。！？」』]/g,

    // -------------------------
    // 【終助詞（感情・ニュアンス）】 (Sentence-final particles)
    // -------------------------
    '〜ね/ねえ（同意・確認）': /ねぇ?[。！？」』]/g,
    '〜よ（主張・通知）': /よ[。！？」』]/g,
    '〜な/なぁ（詠嘆・禁止）': /なぁ?[。！？」』]/g,
    '〜わ（女性的/強調）': /わ[。！？」』]/g,
    '〜ぞ/ぜ（強意・男性的）': /[ぞぜ][。！？」』]/g,
    '〜さ（軽度な断定）': /さ[。！？」』]/g,
    '〜もん（言い訳・甘え）': /もん[。！？」』]/g,
    '〜ジャン（口語・同意）': /(?:じゃん|ジャン)[。！？」』]/g,

    // -------------------------
    // 【命令・依頼・接続】 (Imperative / Request)
    // -------------------------
    '〜て/で（軽い依頼・言いさし）': /[てで][。！？」』]/g,
    '〜ろ/よ（命令）': /[ろよ][!！][。！？」』]?/g, // 感嘆符付きを優先
    '〜なさい（命令・丁寧）': /なさい[。！？」』]/g,
    '〜ください（依頼・丁寧）': /ください[。！？」』]/g,
    '〜たまえ（命令・尊大）': /たまえ[。！？」』]/g,

    // -------------------------
    // 【その他・体言止め・倒置】 (Others)
    // -------------------------
    '体言止め（名詞終了）': /(?:[ぁ-んァ-ヶ]|[一-龠々])[。！？」』]/g, // 少し厳密化：漢字orカナ＋句読点
    // ※体言止めは他のパターンにマッチしなかった場合の「その他」として扱うのが安全です
};
            
            const endingCounts = {};
            let totalEndings = 0;
            
            for (let [pattern, regex] of Object.entries(endingPatterns)) {
                const matches = text.match(regex) || [];
                endingCounts[pattern] = matches.length;
                totalEndings += matches.length;
            }
            
            const endingDistribution = [];
            for (let [pattern, count] of Object.entries(endingCounts)) {
                if (count > 0) {
                    endingDistribution.push({
                        pattern,
                        count,
                        percentage: (count / totalEndings) * 100
                    });
                }
            }
            endingDistribution.sort((a, b) => b.count - a.count);
            
            let entropy = 0;
            for (let item of endingDistribution) {
                const p = item.percentage / 100;
                if (p > 0) entropy -= p * Math.log2(p);
            }
            const maxEntropy = Math.log2(Object.keys(endingPatterns).length);
            const endingVariety = (entropy / maxEntropy) * 100;
            
            const firstPersonMarkers = text.match(/私|僕|俺|わたし|ぼく|おれ|自分|うち/g) || [];
            const thirdPersonMarkers = text.match(/彼|彼女|[一-龯]{1,3}は|[一-龯]{1,3}が/g) || [];
            
            const fpRatio = firstPersonMarkers.length / sentences.length;
            const tpRatio = thirdPersonMarkers.length / sentences.length;
            
            let viewpointConsistency = 'consistent';
            if (fpRatio > 0.3 && tpRatio > 0.3) {
                viewpointConsistency = 'mixed';
            } else if (fpRatio > 0.1 && tpRatio > 0.1) {
                viewpointConsistency = 'slightly_mixed';
            }
            
            const redundantPatterns = [
                /することができる/g,
                /することが可能/g,
                /というもの/g,
                /というわけ/g,
                /ということ/g,
                /〜したりする/g,
                /非常に|とても|すごく|かなり|結構/g,
                /基本的に|一般的に|要するに/g,
                /〜のような気がする/g,
                /〜と思われる/g
            ];
            
            let redundancyCount = 0;
            for (let pattern of redundantPatterns) {
                const matches = text.match(pattern) || [];
                redundancyCount += matches.length;
            }
            
            const redundancyScore = Math.max(0, 100 - (redundancyCount / sentences.length) * 20);
            const redundancyLabel = redundancyCount < 3 ? 'minimal' : redundancyCount < 8 ? 'moderate' : 'excessive';
            
          // 小説向け：文脈をつなぐ良質な接続詞・接続語句（バリエーション増強版）
// 物語の進行、時間経過、感情の機微、場面転換を含む
const goodConnectorsPattern = [
    // 0. 基本的な接続詞（小説で頻出）
    "そして", "でも", "だから", "それで", "また", "そこで",
    
    // 1. 逆接・葛藤（ドラマを生む）
    "しかし", "だが", "けれど", "けれども", "だけど", "ところが",
    "それでも", "なのに", "もっとも", "とはいえ", "だとしても",
    "にもかかわらず", "そうは言っても", "とはいうものの", "ただ", "否",

    // 2. 時間経過・場面展開（物語を進める）
    "やがて", "すると", "その時", "そのとき", "ほどなく", "まもなく",
    "いつしか", "とつぜん", "突然", "不意に", "ふと", "あくる日", "翌日",
    "数日後", "しばらくして", "気付けば", "次の瞬間", "と同時に", "直後",
    "以前", "かつて", "いまや", "今度は", "かくして", "こうして",

    // 3. 添加・強調（情報を畳み掛ける）
    "そのうえ", "しかも", "それに", "さらに", "おまけに", "あまつさえ",
    "そればかりか", "それどころか", "加えて", "のみならず",

    // 4. 原因・理由・心情（キャラクターの動機）
    "なぜなら", "だって", "どうしてかというと", "なにしろ", "なんとなれば",
    "というのも", "ゆえに", "それゆえ", "したがって", "だからこそ",

    // 5. 転換・補足（視点を変える）
    "さて", "ところで", "それはそうと", "一方", "他方", "翻って",
    "ちなみに", "なお", "もっとも", "ただし", "要するに", "つまり", "いわば"
].join("|");

const goodConnectors = text.match(new RegExp(goodConnectorsPattern, "g")) || [];


// 小説向け：避けるべき悪質な接続・冗長表現
// 単調なリズム、稚拙に見える繰り返し、過剰な説明口調
const poorConnectorsPattern = [
    // 単調な繰り返し（頭の悪いリズムになる）
    "そして、そして", "それで、それで", "でも、でも", "だから、だから",
    "また、また", "次に、次に",

    // 小説では好まれない過剰な口語・ネットスラング的接続（文頭限定）
    "^ていうか、", "^てゆーか、", "^なので、",

    // 意味の薄い繋ぎ言葉の連発
    "そうして、そうして", "そうやって、そうやって"
].join("|");

const poorConnectors = text.match(new RegExp(poorConnectorsPattern, "g")) || [];

// 接続詞スコアの改善版（より現実的な評価）
// 基本スコア: 良質な接続詞の使用率を基準とする
const goodConnectorRatio = sentences.length > 0 ? (goodConnectors.length / sentences.length) : 0;

console.log(`接続詞デバッグ: 良質=${goodConnectors.length}, 不適切=${poorConnectors.length}, 文数=${sentences.length}, 比率=${goodConnectorRatio.toFixed(3)}`);

// 現実的なスコアリング
// - 10文に1個（10%）の接続詞で50点
// - 5文に1個（20%）の接続詞で80点
// - 3文に1個（33%）以上で満点
let baseConnectorScore = 0;
if (goodConnectorRatio >= 0.33) {
    baseConnectorScore = 100;
} else if (goodConnectorRatio >= 0.20) {
    // 20%〜33%の範囲: 80〜100点
    baseConnectorScore = 80 + ((goodConnectorRatio - 0.20) / 0.13) * 20;
} else if (goodConnectorRatio >= 0.10) {
    // 10%〜20%の範囲: 50〜80点
    baseConnectorScore = 50 + ((goodConnectorRatio - 0.10) / 0.10) * 30;
} else if (goodConnectorRatio > 0) {
    // 0%〜10%の範囲: 20〜50点（最低20点保証）
    baseConnectorScore = 20 + (goodConnectorRatio / 0.10) * 30;
} else {
    // 接続詞が全くない場合: 30点（基本点）
    baseConnectorScore = 30;
}

// 不適切な接続詞に対するペナルティ
const poorPenalty = poorConnectors.length * 5;

// 最終スコア（最低20点、最高100点）
const connectorScore = Math.max(20, Math.min(100, baseConnectorScore - poorPenalty));
            
            // まず、よく使われる貧弱な表現をカウント
            const poorVocab = {
                'すごい': (text.match(/すごい/g) || []).length,
                'いい感じ': (text.match(/いい感じ|良い感じ/g) || []).length,
                'めっちゃ': (text.match(/めっちゃ|めちゃ/g) || []).length,
                'やばい': (text.match(/やばい|ヤバい/g) || []).length,
                'なんか': (text.match(/なんか|何か/g) || []).length,
                'みたいな': (text.match(/みたいな/g) || []).length,
                'って感じ': (text.match(/って感じ|っぽい感じ/g) || []).length,
                'まあまあ': (text.match(/まあまあ/g) || []).length,
                'ちょっと': (text.match(/ちょっと/g) || []).length,
            };
            
            // テキストから2文字以上の単語を抽出（より細かく）
            const allWords = text.match(/[ぁ-んァ-ヶー一-龠々]+/g) || [];
            const functionalWords = /^(は|が|を|に|へ|と|で|から|まで|より|の|や|か|も|こそ|さえ|だけ|ばかり|など|し|た|て|だ|です|ます|ある|いる|する|なる|れる|られる|せる|させる|ない|ぬ|ん|これ|それ|あれ|この|その|あの|ここ|そこ|あそこ|こう|そう|ああ)$/;
            const contentWords = allWords.filter(w => w.length >= 2 && !functionalWords.test(w));
            const uniqueWords = new Set(contentWords);
            
            const wordFreq = {};
            contentWords.forEach(w => {
                wordFreq[w] = (wordFreq[w] || 0) + 1;
            });
            
            // 頻出語のリスト（コメント表示用）
            const repeatedWords = Object.entries(wordFreq).filter(([w, c]) => c > 2).sort((a, b) => b[1] - a[1]);
            
            // 貧弱な語彙の使用回数をカウント
            let poorVocabCount = 0;
            Object.entries(poorVocab).forEach(([word, count]) => {
                if (count > 0) {
                    poorVocabCount += count;
                }
            });
            
            // 貧弱な語彙の比率を計算（文章の長さに対する割合）
            const poorVocabRatio = contentWords.length > 0 ? (poorVocabCount / contentWords.length) : 0;
            
            // 繰り返しの多い単語の数をカウント
            let highRepeatCount = 0;
            Object.entries(wordFreq).forEach(([word, count]) => {
                if (count >= 5) {
                    highRepeatCount += (count - 4);
                } else if (count >= 3) {
                    highRepeatCount += (count - 2) * 0.5;
                }
            });
            
            // 繰り返しの比率を計算
            const repetitionRatio = contentWords.length > 0 ? (highRepeatCount / contentWords.length) : 0;
            
            // 語彙の多様性を計算
            const diversityRatio = contentWords.length > 0 ? (uniqueWords.size / contentWords.length) : 0;
            
            // 基本スコアは多様性比率に基づく
            let baseScore = 0;
            if (diversityRatio >= 0.8) {
                baseScore = 100;
            } else if (diversityRatio >= 0.5) {
                baseScore = ((diversityRatio - 0.5) / 0.3) * 100;
            } else {
                baseScore = diversityRatio * 100;
            }
            
            // 比率ベースでペナルティを適用（最大減点は50点）
            const poorVocabPenalty = Math.min(30, poorVocabRatio * 100);
            const repetitionPenalty = Math.min(20, repetitionRatio * 100);
            const totalPenalty = poorVocabPenalty + repetitionPenalty;
            const vocabularyRichness = Math.max(0, baseScore - totalPenalty);
            
// ==========================================
// 1. 五感・感覚表現 (Sensory)
// ==========================================
// 視覚、聴覚、嗅覚、味覚、触覚、温度、身体感覚など
const sensoryList = [
    // 視覚
    '見', '観', '眺', '視界', '光景', '眼', '瞳', '目', '眩', '鮮やか', '色', '彩', 
    '薄暗', '闇', '影', '輪郭', 'ぼんやり', '霞', '透明', '煌', '輝', '映',
    // 聴覚
    '音', '声', '響', '聞', '聴', '耳', '囁', '叫', '喚', '悲鳴', '轟音', '静寂', 
    'ざわめき', '喧騒', 'ノイズ', '足音', '物音', '沈黙',
    // 嗅覚
    '香', '匂', '臭', '鼻', '芳', '薫', '嗅', '悪臭', '異臭', '残り香', '鼻をつく',
    // 味覚
    '味', '甘', '辛', '苦', '酸', '渋', '旨', '舌', '噛', '喉越', '不味', '美味',
    // 触覚・温度・身体感覚
    '触', '撫', '感触', '手触', '肌', '皮膚', '指先', '冷', '温', '熱', '寒', '暑', 'ぬくもり',
    '痛', '激痛', '鈍痛', '痒', '痺', '震', '鳥肌', '柔ら', '硬', '重', '軽', '湿', '乾',
    'ざらざら', 'つるつる', 'ふわふわ', 'ベタベタ', 'ひんやり'
];

// ==========================================
// 2. 心理・内面描写 (Psychological)
// ==========================================
// 思考、感情、葛藤、推測、回想など
const psychList = [
    // 思考・意識（大幅強化）
    '思', '考', '感', '気', '心', '胸', '脳裏', '意識', '記憶', '回想', '想像', '妄想', 
    '推測', '予感', '理解', '納得', '把握', '認識', '自覚', '迷', '悩', '疑', '決意',
    '判断', '予想', '直感', 'イメージ', '確信', '信じ',
    '気づ', '悟', '察し', '見抜', '察知', '読み取',
    '思い出', '忘れ', '振り返', '懐かし',
    'わか', '了解', '飲み込', '腑に落ち', '合点', 'ピンと来',
    
    // 感情の動き
    '不安', '恐怖', '喜', '悲', '怒', '驚', '哀', '憂', '憤', '憎', '愛', '恋', '情',
    '期待', '願', '望', '欲', '焦', '悔', '嫉妬', '羨', '安堵', '絶望', '孤独', '虚無',
    '嬉し', '楽し', '幸せ', '満足', '安心', '感動', '興奮',
    '悲し', '哀し', '辛', '苦し', '切な', '寂し', '虚し',
    '腹立', 'イラ', 'ムカ', '不快', '恨',
    '怖', '心配', '緊張', '困惑', '慌て', '動揺',
    'びっくり', '仰天', '呆然', '唖然', '愕然',
    '恥ずかし', '照れ', '気まず', '後ろめた', '罪悪感',
    
    // 内面の声・状態
    '衝動', '本能', '理性', '葛藤', '動揺', '混乱', '放心', '呆然', '意地', 'プライド',
    '冷静', '落ち着', '平静', '集中',
    
    // 推測・判断の助詞（重要！）
    'だろう', 'のか', 'のだ', 'んだ', 'だった', 'かもしれ', 'に違いな',
    'ようだ', 'みたい', 'らしい', 'っぽい', 'はず', 'べき', 'だけ'
];

// ==========================================
// 3. 動作・アクション (Action)
// ==========================================
// 体の動き、移動、戦闘、日常動作など
const actionList = [
    // 移動・足
    '歩', '走', '駆', '跳', '飛', '逃', '追', '進', '退', '戻', '行', '来', '立', '座', 
    '這', '転', '倒', '着地', '徘徊', '彷徨', 'ダッシュ',
    // 手・腕・操作
    '握', '掴', '持', '取', '投', '打', '殴', '叩', '撫', '押', '引', '開', '閉', 
    '振', '指差', '触', '拾', '捨て', '抱', '背負',
    // 口・顔・表情動作
    '言', '話', '語', '叫', '呼', '笑', '泣', '食', '飲', '吐', '噛', '舐', '睨', 
    '頷', '首を振', '見回', '瞬き', '凝視',
    // 戦闘・激しい動作
    '蹴', '斬', '刺', '撃', '射', '防', '避', '殺', '壊', '砕', '裂', '爆発', '衝突'
];

// ==========================================
// 4. 情景・世界観 (Scene)
// ==========================================
// 自然、天候、場所、時間、光と影など
const sceneList = [
    // 天体・天候
    '空', '雲', '太陽', '月', '星', '風', '雨', '雪', '雷', '嵐', '霧', '霞', '虹', 
    '晴', '曇', '気候', '気温', '季節', '陽射し', '夕暮', '朝', '昼', '夜', '深夜',
    // 自然・地形
    '木', '林', '森', '花', '草', '葉', '山', '海', '川', '湖', '水', '土', '砂', '岩', 
    '崖', '地平線', '水平線', '洞窟', '荒野',
    // 人工物・場所
    '街', '都市', '建物', '部屋', '窓', '壁', '床', '天井', '扉', 'ドア', '道', '路地', 
    '広場', '家', '店', '城', '廃墟', 'ガラス', 'コンクリート',
    // 雰囲気・状態
    '光', '影', '色', '静寂', '喧騒', '雰囲気', '空気感', '匂い', '景色', '風景'
];

// ==========================================
// 評価実行関数（修正版）
// ==========================================
// リストを「|」で結合して正規表現オブジェクトを作成
const createRegex = (list) => new RegExp(list.join('|'), 'g');

const sensoryRegex = createRegex(sensoryList);
const psychRegex = createRegex(psychList);
const actionRegex = createRegex(actionList);
const sceneRegex = createRegex(sceneList);

// マッチング数をカウント（null対策で || [] を使用）
const sensoryCount = (text.match(sensoryRegex) || []).length;
const psychCount = (text.match(psychRegex) || []).length;
const actionCount = (text.match(actionRegex) || []).length;
const sceneCount = (text.match(sceneRegex) || []).length;

// 文の数（sentences.length）が0の場合のゼロ除算対策を含める
const sentenceCount = sentences.length > 0 ? sentences.length : 1;

// 密度計算（%）
const sensoryDensity = (sensoryCount / sentenceCount) * 100;
const psychDensity = (psychCount / sentenceCount) * 100;
const actionDensity = (actionCount / sentenceCount) * 100;
const sceneDensity = (sceneCount / sentenceCount) * 100;

// 結果確認用ログ
console.log(`五感度: ${sensoryDensity.toFixed(1)}%`);
console.log(`心理度: ${psychDensity.toFixed(1)}%`);
console.log(`アクション度: ${actionDensity.toFixed(1)}%`);
console.log(`情景度: ${sceneDensity.toFixed(1)}%`);

            // ========== 品質チェック（異常パターン検出） ==========
            let qualityPenalty = 0;
            const qualityIssues = [];
            
            // 1. 読点の過剰使用チェック（1文あたり平均5個以上で警告）
            const commaCount = (text.match(/、/g) || []).length;
            const commaPerSentence = commaCount / sentenceCount;
            if (commaPerSentence > 5) {
                const penalty = Math.min(60, (commaPerSentence - 5) * 12);
                qualityPenalty += penalty;
                qualityIssues.push(`読点過多（1文平均${commaPerSentence.toFixed(1)}個）`);
            }
            
            // 2. ルビ（括弧）の乱用チェック
            const rubyCount = (text.match(/（[^）]+）/g) || []).length;
            const rubyPerSentence = rubyCount / sentenceCount;
            if (rubyPerSentence > 1.5) {
                const penalty = Math.min(40, (rubyPerSentence - 1.5) * 20);
                qualityPenalty += penalty;
                qualityIssues.push(`ルビ過多（1文平均${rubyPerSentence.toFixed(1)}個）`);
            }
            
            // 3. 同じ単語の過度な繰り返しチェック（「俺」など）
            const words = text.match(/[一-龯ぁ-んァ-ヴー]+/g) || [];
            const wordRepeatFreq = {};
            words.forEach(w => {
                if (w.length >= 2) {
                    wordRepeatFreq[w] = (wordRepeatFreq[w] || 0) + 1;
                }
            });
            const maxRepeat = Math.max(0, ...Object.values(wordRepeatFreq));
            const totalWords = words.length;
            if (totalWords > 0 && maxRepeat / totalWords > 0.12) {
                qualityPenalty += 35;
                const mostCommon = Object.keys(wordRepeatFreq).find(k => wordRepeatFreq[k] === maxRepeat);
                qualityIssues.push(`単語の過度な繰り返し（「${mostCommon}」が${maxRepeat}回）`);
            }
            
            // 4. 異常な句読点パターン（「、と、」「、の、」など）
            const weirdCommaPattern = (text.match(/、[とのがをにへでや]、/g) || []).length;
            if (weirdCommaPattern > sentenceCount * 0.25) {
                qualityPenalty += 50;
                qualityIssues.push('不自然な読点の配置');
            }
            
            // 5. 感嘆符・疑問符の過剰使用
            const exclamationCount = (text.match(/！{3,}/g) || []).length;
            if (exclamationCount > sentenceCount * 0.4) {
                qualityPenalty += 25;
                qualityIssues.push('感嘆符の過剰使用');
            }
            
            // 6. 三点リーダー・省略記号の異常使用
            const dotsPattern = (text.match(/\.{3,}|。{2,}/g) || []).length;
            if (dotsPattern > sentenceCount * 0.5) {
                qualityPenalty += 20;
                qualityIssues.push('省略記号の多用');
            }
            
            console.log(`品質ペナルティ: -${qualityPenalty.toFixed(1)}点`, qualityIssues);
            
            // 各密度を0-30点に正規化してから合計（最大120点→100点にクリップ）
            // 係数を上げてスコアが出やすくする
            const normalizedSensory = Math.min(30, sensoryDensity * 1.2);      // 五感描写
            const normalizedPsych = Math.min(30, psychDensity * 1.2);          // 心理描写
            const normalizedAction = Math.min(30, actionDensity * 1.2);        // 動作描写
            const normalizedScene = Math.min(30, sceneDensity * 1.2);          // 情景描写
            
            const rawDescDensity = normalizedSensory + normalizedPsych + normalizedAction + normalizedScene;
            
            // 品質ペナルティを適用（最低0点）
            const totalDescDensity = Math.max(0, Math.min(100, rawDescDensity - qualityPenalty));
            
            const kanjiCount = (text.match(/[一-龯]/g) || []).length;
            const hiraganaCount = (text.match(/[ぁ-ん]/g) || []).length;
            const katakanaCount = (text.match(/[ァ-ヴ]/g) || []).length;
            
            const kanjiRatio = (kanjiCount / totalChars) * 100;
            const hiraganaRatio = (hiraganaCount / totalChars) * 100;
            const katakanaRatio = (katakanaCount / totalChars) * 100;
            
            const keywordRegex = new RegExp(profile.keywords, 'gi');
            const keywordMatches = text.match(keywordRegex) || [];
            
            // キーワード密度の改善版
            // 1文あたりの平均キーワード数を計算
            const keywordsPerSentence = sentences.length > 0 ? (keywordMatches.length / sentences.length) : 0;
            
            // 総文字数に対するキーワードの比率も考慮
            const keywordCharRatio = totalChars > 0 ? (keywordMatches.join('').length / totalChars) : 0;
            
            // 両方の指標を組み合わせて最終的な密度を計算
            const keywordDensity = (keywordsPerSentence * 0.7) + (keywordCharRatio * 100 * 0.3);
            
            console.log(`ジャンルキーワード: マッチ数=${keywordMatches.length}, 文数=${sentences.length}, 文あたり=${keywordsPerSentence.toFixed(2)}, 密度=${keywordDensity.toFixed(2)}`);
        // ポジティブワード（喜び、愛、希望、勝利、安らぎ、称賛）
/**
 * 高精度版：感情分析用単語リスト＆タイムライン生成コード
 * * 拡張ポイント：
 * - 語彙数を大幅に増加（日常会話、ビジネス、熟語、感情表現を網羅）
 * - 配列管理によるメンテナンス性の向上
 */

// ==========================================
// ポジティブワード定義（配列で管理）
// ==========================================
// ==========================================
// ポジティブワード定義（配列で管理）
// ==========================================
const positiveList = [
    // --- 喜び・幸福・快楽・笑い ---
    '嬉し', '楽し', '幸せ', '幸', '喜', '笑', 'ハッピー', '快哉', '愉快', '歓喜',
    '悦', '満喫', '堪能', '心地よ', '心地良', '快感', '快楽', 'ウキウキ', 'ワクワク',
    'ルンルン', '上機嫌', 'ご機嫌', '笑顔', '微笑', '爆笑', '大笑', '談笑', '哄笑',
    '破顔', '頬が緩', '口元が緩', '朗ら', '陽気', '浮かれ', '有頂天', '舞い上が',
    '至福', '冥利', '醍醐味', '満悦', '欣喜', '雀躍', '喜色', '会心', '面白',
    'おかしい', '滑稽', 'ユーモア', '愛嬌', '和やか', '和気', 'はしゃ', '狂喜',

    // --- 愛・信頼・絆・優しさ ---
    '好', '愛', '恋', '惚', '絆', '信頼', '信用', '親愛', '熱愛', '溺愛', '最愛',
    '慕', '懐', '仲良', '仲間', '相棒', '親友', '盟友', '団結', '結束', '協力',
    '協調', '和解', '融和', '包容', '優し', '温か', '思いやり', '慈', '仁',
    '慈愛', '恩義', '恩', '義理', '人情', '友情', '初恋', '純愛', '求愛', '相思相愛',
    '寄り添', '支え', '助け', '守る', '庇う', '抱擁', 'ハグ', 'キス', '口付',
    '同情', '共感', '共鳴', '親切', '丁寧', '厚意', '好意', '懇意', '昵懇',

    // --- 称賛・尊敬・評価・魅力 ---
    '素晴ら', '素敵', '見事', '立派', '流石', 'さすが', '称賛', '賞賛', '絶賛',
    '尊敬', '敬意', '憧れ', '誇', '名誉', '栄光', '有能', '天才', '秀才', '英知',
    '賢', '聡明', '鋭', '巧', '上手', 'プロ', '熟練', '達人', '傑作', '名作',
    '良', '善', '好感', '魅了', '魅力', 'カリスマ', 'イケメン', '美人', '可憐',
    '美貌', '男前', 'ハンサム', '麗し', '凛々', '清楚', '妖艶', 'あどけな', '健気',
    '殊勝', '勇敢', '勇者', '英雄', '高潔', '気高い', '崇高', '神々', '尊',
    '称え', '褒め', '感服', '感心', '心酔', '一目置', '最高', '極上', '至高',

    // --- 成功・勝利・達成・進歩 ---
    '成功', '成し遂', '達成', '勝利', '勝', '優勝', '制覇', '突破', '克服', '解決',
    '完遂', '完了', '成就', '実現', '開花', '実り', '収穫', '獲得', 'ゲット',
    '当たり', '当選', '合格', '採用', '内定', '昇進', '昇格', '栄転', '躍進',
    '発展', '進化', '成長', '向上', '改善', '好転', '回復', '復帰', '再起',
    '凱旋', '金字塔', '栄冠', 'トロフィー', '勲章', '手柄', '功績', '貢献',
    'うまくい', '順調', '捗る', '進捗', '前進', '飛躍', '刷新', '洗練',

    // --- 希望・運・未来・光 ---
    '希望', '夢', '期待', '待望', '予感', '可能性', '展望', '光明', '光', '輝',
    '運', 'ツキ', 'ラッキー', '幸運', '奇跡', '神', '天国', '極楽', '吉', '福',
    'チャンス', '好機', '有利', '有望', '安泰', '前途', '夜明け', '曙', '朝日',
    '眩し', '煌', '燦然', '祝福', '祈り', '願', '救済', '救い', '助か', '生き延',
    '無限', '永遠', '不滅', '安寧', '息吹', '予兆', '吉報', '朗報',

    // --- 安心・癒やし・美・雰囲気 ---
    '安心', '安ら', '癒', 'リラックス', 'のんびり', 'まったり', 'ほっこり', '平穏',
    '平和', '無事', '安全', '健全', '健康', '元気', '活発', '爽快', '清々', '清らか',
    '綺麗', '美し', '麗', '華やか', '雅', '美味', 'うま', '旨', '絶品',
    '静寂', '静謐', '落ち着', '緩和', '休息', '休憩', '眠り', '快眠', '熟睡',
    '壮大', '雄大', '幻想', '神秘', '情緒', '風流', '趣', '粋', '乙',
    '豊か', '芳醇', '濃厚', '新鮮', '瑞々', '潤', '透明', '澄', '浄化'
];

// ==========================================
// ネガティブワード定義（配列で管理）
// ==========================================
const negativeList = [
    // --- 悲しみ・苦痛・孤独・喪失 ---
    '悲し', '辛', '苦し', '痛', '泣', '涙', '号泣', '嘆', '哀', '傷', '孤独',
    '寂', '孤立', '疎外', '別れ', '失恋', '喪失', '失', '亡', '死', '遺体', '葬',
    '不幸', '薄幸', '惨', '残酷', '無念', '残念', '気の毒', '哀れ', '憐',
    '嗚咽', '慟哭', '愁', '憂', '鬱', '沈', '暗', '陰', '虚', '空虚', '虚無',
    '絶望', '落胆', 'がっかり', '失望', '幻滅', '未練', '追悼', '供養', '墓',
    '切な', 'やるせな', '悶え', '懊悩', '心痛', '断腸', '悲劇', '惨劇', '災',

    // --- 怒り・憎悪・敵意・暴力 ---
    '怒', '腹立', 'ムカ', 'イラ', '憤', '激怒', '憎', '嫌', '仇', '敵', '恨',
    '妬', '嫉妬', '殺意', '殺害', '害', '虐', '罵', '暴言', '暴力', '暴行', '喧嘩',
    '争', '対立', '抗争', '紛争', '揉め', '非難', '批判', '中傷', '誹謗', '炎上',
    'クズ', 'ゴミ', 'カス', '死ね', 'ウザ', 'キモ', '地獄', '悪夢',
    '殺伐', '敵意', '害意', '悪意', '邪悪', '魔', '呪', '祟', '怨', '逆鱗',
    '威嚇', '脅', '睨', '舌打ち', '野蛮', '制裁', '粛清', '弾圧', '拷問',
    'リンチ', '抹殺', '排除', '追放', '袋叩き', 'フルボッコ', '最悪', '最低',
    '侮蔑', '軽蔑', '見下', '嘲笑', '冷笑', '愚弄', 'バカ', 'アホ', '間抜け',

    // --- 恐怖・不安・危機 ---
    '怖', '恐', '怯', '震', 'ビビ', '不安', '心配', '懸念', '危惧', '焦', 'パニック',
    '脅威', '危機', 'ピンチ', '危険', 'リスク', '不吉', '悪寒', '戦慄', '畏怖',
    '動揺', '狼狽', '混乱', '錯乱', '発狂', '狂気', '気味悪', '不気味', '怪奇',
    'ホラー', '妖怪', '幽霊', '怪物', '化け物', 'トラウマ', '強迫', '切迫',
    '焦燥', '冷や汗', '脂汗', '鳥肌', '蒼白', '顔面蒼白', 'ガクブル', '躊躇', '逡巡',
    '逃亡', '敗走', '退却', '遭難', '拉致', '監禁', '拘束', '束縛',

    // --- 失敗・損失・後悔・無力 ---
    '失敗', '敗北', '負け', '敗戦', '脱落', '落選', '不合格', '落ち', 'ミス',
    '過ち', '誤', '損', '赤字', '借金', '貧困', '欠陥', '不良', '故障', 'バグ',
    'エラー', '不具合', '邪魔', '妨害', '遅延', '停滞', '後悔', '悔', '反省',
    '懺悔', '罪', '罰', '謝罪', '詫', '自責', '罪悪感', '引け目',
    '諦', '断念', '無理', '駄目', '限界', '手遅れ', '終', 'オワコン',
    '挫折', '屈辱', '屈服', '降参', '白旗', '土下座', '破滅', '破産', '倒産',
    '没落', '崩壊', '全滅', '壊滅', '大破', '粉砕', '粉々', 'ボロボロ',
    '無力', '無能', '役立たず', '足手まとい', '徒労', '無駄', '水の泡',

    // --- 不快・嫌悪・疲労・病 ---
    '不快', '不満', '不平', '文句', '愚痴', '劣悪', '汚', '臭',
    '腐', '醜', '卑怯', '卑劣', '狡猾', '悪', '邪', '偽', '嘘', '詐欺', '騙',
    '裏切', '疲', '倦怠', '過労', 'バテ', 'ダル', '面倒', '退屈', '飽',
    '憂鬱', '陰湿', '違和感', '吐き気', '気絶', '倒',
    '病', '患', '痛', '激痛', '苦悶', '呻', '吐血', '怪我', '負傷', '重傷',
    '致命傷', '衰弱', '老衰', 'やつれ', '憔悴', '疲弊', '消耗', '泥沼',
    '辟易', 'うんざり', '幻滅', '嫌気', 'ドン引', '生理的', '鼻につく', '耳障り'
];

// 配列を正規表現パターン文字列に結合 ('|'で繋ぐ)
const positivePattern = positiveList.join('|');
const negativePattern = negativeList.join('|');

// 正規表現オブジェクトの生成
const posRegex = new RegExp(positivePattern, 'g');
const negRegex = new RegExp(negativePattern, 'g');

// ==========================================
// 解析ロジック実行部
// ==========================================

// text変数は外部から与えられる想定
// const text = "ここに解析したい文章が入ります..."; 

// 全体のマッチング（単語リスト取得用）
const positiveWords = text.match(posRegex) || [];
const negativeWords = text.match(negRegex) || [];

// タイムラインの生成
const sentimentTimeline = [];
// チャンクサイズを動的に調整（最低でも1文字以上、基本は長さの1/20）
const chunkSize = Math.max(1, Math.ceil(text.length / 20)); 

// 分割数はテキスト長に応じて最大20、短い場合はそれ以下になるよう調整
const steps = Math.ceil(text.length / chunkSize);

for (let i = 0; i < steps; i++) {
    const chunk = text.slice(i * chunkSize, (i + 1) * chunkSize);
    
    // 拡張された正規表現を使ってカウント
    const pos = (chunk.match(posRegex) || []).length;
    const neg = (chunk.match(negRegex) || []).length;
    
    // スコア計算
    // 単純な引き算に加え、全体数に対する比率なども考慮可能だが、
    // ここでは視認性を高めるためシンプルに強調（* 2）
    const score = (pos - neg) * 2;
    sentimentTimeline.push(score); 
}

// 結果の出力（デバッグ用）
console.log("Positive Count:", positiveWords.length);
console.log("Negative Count:", negativeWords.length);
console.log("Score Timeline:", sentimentTimeline);
console.log("Sample Words:", positiveWords.slice(0, 5), negativeWords.slice(0, 5));
            const overallSentiment = positiveWords.length - negativeWords.length;
            
            const w = profile.weights;
            
            // 語彙力スコア（重みを2倍に強化）
            const vocabScore = vocabularyRichness * (w.vocab || 1) * 2.0;
            
            // 他のスコア（底上げボーナスを削減）
            const descScore = Math.min(100, totalDescDensity * 1.2) * (w.description || 1);  // ボーナス削除
            const dialogScore = (Math.max(0, 100 - Math.abs(dialogRatio - profile.minDialog) * 1.0) + 5) * (w.dialogue || 1);
            const sentimentScore = (Math.min(100, (positiveWords.length + negativeWords.length) * 5) + 5) * (w.sentiment || 1);
            const endingScore = (endingVariety + 10) * (w.ending || 1);
            const viewpointScore = (viewpointConsistency === 'consistent' ? 100 : viewpointConsistency === 'slightly_mixed' ? 85 : 60) * (w.viewpoint || 1);
            const idealVariance = 0.3;
            const tempoScore = (Math.max(0, 100 - Math.abs(tempoVariance - idealVariance) * 100) + 5) * (w.tempo || 1);
            const redundScore = (redundancyScore + 5) * (w.redundancy || 1);
            const connectorFinalScore = (Math.max(0, connectorScore) + 5) * (w.connector || 1);
            
            // キーワードスコアの改善版
            // より寛容な評価基準:
            // - 密度0.5以上で80点
            // - 密度1.0以上で100点
            let baseKeywordScore = 0;
            if (keywordDensity >= 1.0) {
                baseKeywordScore = 100;
            } else if (keywordDensity >= 0.5) {
                // 0.5〜1.0の範囲: 80〜100点
                baseKeywordScore = 80 + ((keywordDensity - 0.5) / 0.5) * 20;
            } else if (keywordDensity >= 0.2) {
                // 0.2〜0.5の範囲: 50〜80点
                baseKeywordScore = 50 + ((keywordDensity - 0.2) / 0.3) * 30;
            } else if (keywordDensity > 0) {
                // 0〜0.2の範囲: 30〜50点
                baseKeywordScore = 30 + (keywordDensity / 0.2) * 20;
            } else {
                // キーワードが全くない場合: 20点
                baseKeywordScore = 20;
            }
            
            const keywordScore = (baseKeywordScore + 10) * (w.keyword || 1);
            
            // 重みの合計を計算（語彙力の重みは2倍されているのでそれを反映）
            const totalWeight = (w.vocab * 2.0) + Object.entries(w).filter(([k]) => k !== 'vocab').reduce((sum, [, val]) => sum + val, 0);
            let totalScore = ((vocabScore + descScore + dialogScore + sentimentScore + endingScore + 
                              viewpointScore + tempoScore + redundScore + connectorFinalScore + keywordScore) / totalWeight) + 2;  // +2ボーナス
            
            // 語彙力が極端に低い場合、総合点にさらにペナルティ
            if (vocabularyRichness < 20) {
                totalScore = totalScore * 0.7;  // 30%減点
            } else if (vocabularyRichness < 40) {
                totalScore = totalScore * 0.85;  // 15%減点
            }
            
            // 描写密度が極端に低い場合も総合点にペナルティ（閾値を下げて緩和）
            if (totalDescDensity < 5) {
                totalScore = totalScore * 0.7;  // 30%減点（致命的）
            } else if (totalDescDensity < 15) {
                totalScore = totalScore * 0.85;  // 15%減点
            } else if (totalDescDensity < 30) {
                totalScore = totalScore * 0.95;  // 5%減点
            }
            
            // 文末バリエーションが低い場合も総合点にペナルティ
            if (endingVariety < 30) {
                totalScore = totalScore * 0.75;  // 25%減点（かなり単調）
            } else if (endingVariety < 50) {
                totalScore = totalScore * 0.88;  // 12%減点（やや単調）
            } else if (endingVariety < 65) {
                totalScore = totalScore * 0.95;  // 5%減点（少し単調）
            }
            
            let rank = 'D';
            if (totalScore >= 90) rank = 'SS';
            else if (totalScore >= 80) rank = 'S';
            else if (totalScore >= 70) rank = 'A';
            else if (totalScore >= 60) rank = 'B';
            else if (totalScore >= 50) rank = 'C';
            
            const comment = generateComment(rank, totalScore, profile, {
                dialogRatio, avgLen, endingVariety, viewpointConsistency, 
                redundancyLabel, vocabularyRichness, totalDescDensity
            });
            
            const tags = generateTags(totalScore, dialogRatio, avgLen, keywordDensity, endingVariety);
            
            return {
                rank,
                totalScore,
                comment,
                tags,
                mainMetrics: [
                    { label: '段落数', value: sentences.length, sub: `平均${avgLen.toFixed(1)}文字/文` },
                    { label: '会話比率', value: dialogRatio.toFixed(1) + '%', sub: `${dialogLines.length}個の会話` },
                    { label: '語彙豊富度', value: vocabularyRichness.toFixed(1) + '%', sub: `${uniqueWords.size}種の語彙` },
                    { label: '描写密度', value: totalDescDensity.toFixed(1), sub: '感覚+心理+動作+情景' }
                ],
                radarData: [
                    { label: '語彙力', score: Math.round(vocabularyRichness) },
                    { label: '描写力', score: Math.min(100, totalDescDensity * 1.2) },
                    { label: '会話', score: Math.max(0, 100 - Math.abs(dialogRatio - profile.minDialog) * 1.0) },
                    { label: '感情表現', score: Math.min(100, (positiveWords.length + negativeWords.length) * 5) },
                    { label: '文末変化', score: endingVariety },
                    { label: 'テンポ', score: Math.max(0, 100 - Math.abs(tempoVariance - 0.3) * 100) }
                ],
                qualityMetrics: [
                    { label: '語彙の豊かさ', score: Math.round(vocabularyRichness), 
                      comment: repeatedWords.length > 0 ? `「${repeatedWords[0][0]}」(${repeatedWords[0][1]}回)など繰り返しあり` : '多様な語彙を使用' },
                    { label: '描写の多層性', score: Math.round(Math.min(100, totalDescDensity * 1.2)), 
                      comment: `感覚${sensoryDensity.toFixed(0)}% 心理${psychDensity.toFixed(0)}% 動作${actionDensity.toFixed(0)}%` },
                    { label: '会話の自然さ', score: Math.round(Math.max(0, 100 - Math.abs(dialogRatio - profile.minDialog) * 1.0)), 
                      comment: dialogRatio > profile.minDialog + 20 ? '会話がやや多め' : dialogRatio < profile.minDialog - 20 ? '会話が少なめ' : 'バランス良好' },
                    { label: '文末バリエーション', score: Math.round(endingVariety), 
                      comment: endingVariety > 70 ? '豊富な文末表現' : endingVariety > 50 ? 'やや単調' : '文末パターンが限定的' },
                    { label: '視点の一貫性', score: viewpointConsistency === 'consistent' ? 100 : viewpointConsistency === 'slightly_mixed' ? 70 : 40, 
                      comment: viewpointConsistency === 'consistent' ? '視点が統一されている' : '一人称・三人称の混在あり' },
                    { label: '文章の簡潔性', score: Math.round(redundancyScore), 
                      comment: redundancyLabel === 'minimal' ? '簡潔で読みやすい' : '冗長表現を削減すると良い' },
                    { label: 'テンポの良さ', score: Math.round(Math.max(0, 100 - Math.abs(tempoVariance - 0.3) * 100)), 
                      comment: tempoVariance > 0.5 ? '文長の差が大きい' : tempoVariance < 0.2 ? '文長が単調' : 'リズムが良好' },
                    { label: '接続詞の適切性', score: Math.round(Math.max(0, connectorScore)), 
                      comment: connectorScore > 70 ? '論理展開が明確' : '接続詞を効果的に使うと読みやすくなる' },
                    { label: 'ジャンル適合度', score: Math.round(baseKeywordScore), 
                      comment: keywordDensity >= 0.5 ? `${profile.name}らしさが出ている` : keywordDensity >= 0.2 ? `${profile.name}の要素あり` : 'ジャンル要素を増やすと良い' },
                    { label: '漢字バランス', score: Math.round(Math.max(0, 100 - Math.abs(kanjiRatio - 27) * 3)), 
                      comment: kanjiRatio > 40 ? '漢字が多く硬い' : kanjiRatio < 18 ? 'ひらがなが多め' : '適切なバランス' }
                ],
                contentMetrics: {
                    avgLen,
                    dialogRatio,
                    kanjiRatio,
                    hiraganaRatio,
                    katakanaRatio,
                    viewpointConsistency,
                    redundancyLabel,
                    keywordDensity,
                    endingPatterns: endingDistribution.slice(0, 5),
                    endingVariety,
                    sentimentTimeline,
                    sensoryDensity,
                    psychDensity,
                    actionDensity,
                    sceneDensity,
                    vocabularyRichness,
                    tempoVariance,
                    repeatedWords: repeatedWords.slice(0, 3)
                }
            };
        };

        const generateComment = (rank, score, profile, metrics) => {
            const comments = {
                SS: [
                    `${profile.name}として極めて高い完成度です。語彙の選択、描写の密度、文章のリズムすべてが秀逸で、読者を引き込む力があります。`,
                    `プロ作家レベルの文章力です。${profile.name}の特徴を完璧に捉え、独自の文体を確立しています。このクオリティなら商業出版も十分視野に入ります。`
                ],
                S: [
                    `${profile.name}として非常に高い水準です。文末表現の豊かさ、描写の多層性が際立っており、読者を飽きさせない工夫が随所に見られます。`,
                    `優れた文章です。${profile.name}らしさを保ちながら、独自の個性も光っています。さらに磨けば傑作になる可能性を秘めています。`
                ],
                A: [
                    `${profile.name}として良質な文章です。基本的な技術は確立されており、読みやすく魅力的です。細部を磨くことでさらに向上します。`,
                    `しっかりとした文章力があります。${profile.name}の要素を適切に取り入れており、読者の期待に応える内容になっています。`
                ],
                B: [
                    `${profile.name}としての基礎はできています。いくつかの改善点（${getMainIssue(metrics)}など）に取り組むことで、より魅力的になるでしょう。`,
                    `まずまずの出来です。${profile.name}らしさは感じられますが、文章のメリハリや表現の工夫でさらに良くなります。`
                ],
                C: [
                    `${profile.name}の基本要素は含まれていますが、まだ伸びしろが大きいです。特に${getMainIssue(metrics)}の改善に注力しましょう。`,
                    `基礎的な文章は書けていますが、${profile.name}としての特徴が薄めです。描写や会話の工夫で個性を出していきましょう。`
                ],
                D: [
                    `${profile.name}としてはまだ発展途上です。${getMainIssue(metrics)}などの基本から見直し、一歩ずつ改善していきましょう。`,
                    `改善の余地が多くあります。焦らず、文章の基本（文末表現、視点、描写）から丁寧に磨いていくことをお勧めします。`
                ]
            };
            
            const rankComments = comments[rank] || comments.D;
            return rankComments[Math.floor(Math.random() * rankComments.length)];
        };

        const getMainIssue = (m) => {
            const issues = [];
            if (m.endingVariety < 30) issues.push('文末パターンの単調さ');
            if (m.viewpointConsistency === 'mixed') issues.push('視点の混在');
            if (m.redundancyLabel === 'excessive') issues.push('冗長表現');
            if (m.vocabularyRichness < 30) issues.push('語彙の乏しさ');
            if (m.totalDescDensity < 40) issues.push('描写の薄さ');
            return issues[0] || '全体的なバランス';
        };

        const generateTags = (score, dialogRatio, avgLen, keywordDensity, endingVariety) => {
            const tags = [];
            if (score >= 80) tags.push('高品質');
            if (dialogRatio > 45) tags.push('会話多め');
            if (dialogRatio < 25) tags.push('地の文中心');
            if (avgLen > 60) tags.push('長文型');
            if (avgLen < 35) tags.push('短文型');
            if (keywordDensity > 0.6) tags.push('ジャンル色濃厚');
            if (endingVariety > 70) tags.push('文末多彩');
            if (endingVariety < 50) tags.push('文末改善推奨');
            return tags.slice(0, 5);
        };

        const getScoreColor = (score) => {
            if (score >= 80) return 'bg-gradient-to-r from-green-500 to-emerald-600';
            if (score >= 60) return 'bg-gradient-to-r from-blue-500 to-cyan-600';
            if (score >= 40) return 'bg-gradient-to-r from-yellow-500 to-orange-500';
            return 'bg-gradient-to-r from-red-500 to-pink-600';
        };

        const getScoreBg = (score) => {
            if (score >= 80) return 'badge-success';
            if (score >= 60) return 'badge-info';
            if (score >= 40) return 'badge-warning';
            return 'badge-error';
        };

        const generateAdvice = (m, p) => {
            const list = [];
            
            if (Math.abs(m.avgLen - p.targetLen) > 30) {
                list.push({ 
                    label: '平均文長', 
                    value: Math.round(m.avgLen) + '文字', 
                    target: `${p.targetLen}文字前後`, 
                    statusBadge: 'badge-warning', 
                    msg: m.avgLen > p.targetLen ? '文が長めです。読みやすさ重視なら短縮を検討。' : '文が短めです。描写を増やすと深みが出ます。'
                });
            }
            
            if (m.kanjiRatio > 50 || m.kanjiRatio < 12) {
                list.push({ 
                    label: '漢字率', 
                    value: Math.round(m.kanjiRatio) + '%', 
                    target: '20-35%', 
                    statusBadge: 'badge-warning', 
                    msg: m.kanjiRatio > 40 ? '漢字が多く硬い印象。ひらがなを増やすと柔らかくなります。' : 'やや平仮名が多め。漢字を増やすと締まります。'
                });
            }
            
            if (m.viewpointConsistency !== 'consistent') {
                list.push({ 
                    label: '視点一貫性', 
                    value: m.viewpointConsistency === 'mixed' ? '混在あり' : 'やや混在', 
                    target: '一貫', 
                    statusBadge: 'badge-error', 
                    msg: '一人称・三人称の混在が見られます。視点を統一すると読みやすくなります。'
                });
            }
            
            if (m.redundancyLabel !== 'minimal') {
                list.push({ 
                    label: '冗長表現', 
                    value: m.redundancyLabel === 'excessive' ? '多い' : 'やや多い', 
                    target: '最小限', 
                    statusBadge: 'badge-warning', 
                    msg: '「することができる」「というもの」等の冗長表現が目立ちます。簡潔に書き直しましょう。'
                });
            }
            
            if (m.endingVariety < 40) {
                list.push({ 
                    label: '文末バリエーション', 
                    value: Math.round(m.endingVariety) + '点', 
                    target: '50点以上', 
                    statusBadge: 'badge-warning', 
                    msg: '文末パターンが単調です。「〜た」以外の表現（体言止め、疑問形など）を増やしましょう。'
                });
            }
            
            if (m.vocabularyRichness < 50) {
                let vocabularyMsg = '';
                let vocabularyTarget = '';
                let vocabularyBadge = 'badge-warning';
                
                if (m.vocabularyRichness < 30) {
                    vocabularyMsg = `語彙の多様性が著しく不足しています。${m.repeatedWords.length > 0 ? `「${m.repeatedWords.slice(0, 3).map(w => w[0]).join('」「')}」などの` : ''}同じ語の繰り返しが目立ちます。類語辞典を活用し、表現のバリエーションを増やしましょう。`;
                    vocabularyTarget = '50%以上推奨';
                    vocabularyBadge = 'badge-error';
                } else if (m.vocabularyRichness < 40) {
                    vocabularyMsg = `語彙の繰り返しがやや多く見られます。${m.repeatedWords.length > 0 ? `特に「${m.repeatedWords.slice(0, 2).map(w => w[0]).join('」「')}」など。` : ''}もう少し多様な表現を心がけると、文章に深みが出ます。`;
                    vocabularyTarget = '50%以上推奨';
                    vocabularyBadge = 'badge-warning';
                } else {
                    vocabularyMsg = `語彙はまずまずですが、${m.repeatedWords.length > 0 ? `「${m.repeatedWords[0][0]}」などの` : ''}一部の語の繰り返しが見られます。類語を使うとさらに洗練された文章になります。`;
                    vocabularyTarget = '50%以上推奨';
                    vocabularyBadge = 'badge-info';
                }
                
                list.push({ 
                    label: '語彙の豊かさ', 
                    value: Math.round(m.vocabularyRichness) + '%', 
                    target: vocabularyTarget, 
                    statusBadge: vocabularyBadge, 
                    msg: vocabularyMsg
                });
            }
            
            if (m.tempoVariance < 0.10) {
                list.push({ 
                    label: '文章のリズム', 
                    value: '単調', 
                    target: '適度な変化', 
                    statusBadge: 'badge-info', 
                    msg: '文長がほぼ同じで単調です。長短を織り交ぜるとリズムが生まれます。'
                });
            }
            
            if (m.tempoVariance > 0.7) {
                list.push({ 
                    label: '文章のリズム', 
                    value: 'ばらつき大', 
                    target: '適度な変化', 
                    statusBadge: 'badge-warning', 
                    msg: '文長の差が大きすぎます。もう少し均一にすると読みやすくなります。'
                });
            }
            
            if (m.keywordDensity < 0.2) {
                list.push({ 
                    label: 'ジャンル要素', 
                    value: m.keywordDensity.toFixed(2), 
                    target: '0.5以上推奨', 
                    statusBadge: 'badge-info', 
                    msg: `${p.name}らしいキーワードを増やすと、ジャンルの雰囲気がより強まります。`
                });
            }
            
            if (m.sensoryDensity < 15 && p.name.includes('純文学')) {
                list.push({ 
                    label: '感覚描写', 
                    value: Math.round(m.sensoryDensity) + '%', 
                    target: '20%以上', 
                    statusBadge: 'badge-info', 
                    msg: '視覚・聴覚・触覚などの五感描写を増やすと、臨場感が高まります。'
                });
            }
            
            adviceList.value = list.slice(0, 8);
        };

        const renderCharts = (data) => {
            const ctxRadar = document.getElementById('radarChart');
            const ctxSentiment = document.getElementById('sentimentChart');
            if (radarChart) radarChart.destroy();
            if (sentimentChart) sentimentChart.destroy();

            const gridColor = isDarkMode.value ? '#334155' : '#e2e8f0';
            const textColor = isDarkMode.value ? '#cbd5e1' : '#475569';
            
            radarChart = new Chart(ctxRadar, {
                type: 'radar',
                data: {
                    labels: data.radarData.map(d => d.label),
                    datasets: [{ 
                        label: 'スコア', 
                        data: data.radarData.map(d => d.score), 
                        backgroundColor: 'rgba(56, 189, 248, 0.25)', 
                        borderColor: '#38bdf8', 
                        borderWidth: 3,
                        pointBackgroundColor: '#38bdf8',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 5
                    }]
                },
                options: { 
                    maintainAspectRatio: false, 
                    scales: { 
                        r: { 
                            min: 0, 
                            max: 100, 
                            grid: { color: gridColor }, 
                            ticks: { 
                                display: true,
                                stepSize: 25,
                                color: textColor,
                                backdropColor: 'transparent'
                            },
                            pointLabels: {
                                color: textColor,
                                font: { size: 12, weight: 'bold' }
                            }
                        } 
                    }, 
                    plugins: { legend: { display: false } } 
                }
            });

            sentimentChart = new Chart(ctxSentiment, {
                type: 'line',
                data: {
                    labels: data.contentMetrics.sentimentTimeline.map((_, i) => i),
                    datasets: [{ 
                        data: data.contentMetrics.sentimentTimeline, 
                        borderColor: '#f472b6', 
                        backgroundColor: 'rgba(244, 114, 182, 0.15)', 
                        fill: true, 
                        tension: 0.4, 
                        pointRadius: 2,
                        pointHoverRadius: 6,
                        borderWidth: 3
                    }]
                },
                options: { 
                    maintainAspectRatio: false, 
                    scales: { 
                        x: { display: false }, 
                        y: { 
                            display: true,
                            min: -10, 
                            max: 10,
                            grid: { color: gridColor },
                            ticks: { color: textColor }
                        } 
                    }, 
                    plugins: { 
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    return value > 0 ? `ポジティブ: ${value.toFixed(1)}` : `ネガティブ: ${value.toFixed(1)}`;
                                }
                            }
                        }
                    } 
                }
            });
        };

        // ページ読み込み時にlocalStorageから同意状態を読み込む
        onMounted(() => {
            try {
                const agreed = localStorage.getItem('aiTermsAgreed');
                if (agreed === 'true') {
                    hasAgreedToAITerms.value = true;
                }
            } catch (e) {
                console.warn('localStorage not available');
            }
            
            // テーマの読み込み
            try {
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme === 'night') {
                    isDarkMode.value = true;
                }
            } catch (e) {
                console.warn('localStorage not available');
            }
        });

        return { 
            inputText, selectedGenre, groupedGenres, isProcessing, stats, adviceList, 
            isDarkMode, toastMessage, toastType, toastIcon, currentScoringProfile, 
            isAIMode, aiComment, isAIProcessing, showAITermsModal, hasAgreedToAITerms,
            analyzeText, analyzeWithAI, getScoreColor, getScoreBg, rankColorClass, rankGradient, shareResult,
            acceptAITerms, declineAITerms, onGenreChange, shareToXDirect, copyResultText, downloadCard, shareToLine
        };
    }
}).mount('#app');
</script>
</body>
</html>
